# OS 01 程序的运行过程：从代码到机器运行

## 程序的编译过程

通过CSAPP或者一些C语言编程入门书籍，我们知道C语言的编译分为四步：**预处理阶段，编译阶段，汇编阶段，链接阶段**

GCC为每个阶段提供了对应的工具，从而形成了相应的工具链（**GCC预处理器，GCC编译器，GCC汇编器，GCC链接器**）



我们可以通过选择指令参数让编译过程停在某一阶段

预处理：gcc -E -o 加入头文件、替换宏

编译：gcc -S -c -o 这里已经包含预处理，把C语言转为预处理

汇编：gcc -c -o 包含预处理和编译，将汇编语言转为可以链接的二进制程序

链接器：gcc -o 包含以上所有操作，将可链接的二进制程序和其他库链接在一起，形成可执行的程序文件

![image-20211130185719707](https://i.loli.net/2021/11/30/MhgiL4E8y3BWNSp.png)

## 程序装载运行

图灵机：无限长的纸带，一个读头。读头根据纸袋信息来回移动，读取并写入数据

但是这不现实，我们没有无限长的纸带啊，读头来回移动也太麻烦了吧



图灵机不过是个抽象模型，存在于理想之中，而冯诺依曼设计了相应的体系结构化抽象为具体。



冯诺依曼体系有如下功能需求，为了实现这些功能需求我们需要相应的部件

| 功能需求                                         | 基本部件                             | 专业术语 |
| ------------------------------------------------ | ------------------------------------ | -------- |
| 把程序和数据装入到计算机                         | 装程序和数据的部件                   | 输入设备 |
| 能够**长期**记住程序数据的中间计算结果和最终结果 | 长期记住中间计算结果和最终结果的部件 | 存储器   |
| 能够做数据运算，数据运送，数据加工数据           | 能够处理数据的部件                   | 运算器   |
| 能够控制程序纵向，根据指令控制机器协调工作       | 能控制程序流程的部件                 | 控制器   |
| 能够显示处理结果给客户                           | 能够显示结果的部件                   | 输出设备 |

图灵机的读头相当于控制存储单元，可以大致等同于我们平常说的CPU，集合了寄存器组，逻辑控制单元，计算单元等。

图灵机的纸带相当于存储设备，可以大致等同于内存、磁盘这类存储器。



冯诺依曼体系的核心是计算和存储分离，但这个玩意目前还没有完全分离，大多数情况下空间上仍然是绑定在一起的。**把他们连接在一起的就是各种总线：数据总线，控制总线，地址总线**。

但是随着网速越来越快，或许空间上的绑定会逐步消失，达到真正的分离吧。



## 自问自答（核心）

### 1.call和ret指令在逻辑上执行的操作是怎么样？

> CALL 指令调用一个过程，指挥处理器从**新的内存地址开始执行**。过程使用 RET（从过程返回）指令将处理器转回到该过程**被调用的程序点上**。从物理上来说，CALL 指令将其返回地址压入堆栈，再把被调用过程的地址复制到指令指针寄存器。当过程准备返回时，它的 RET 指令从堆栈把返回地址弹回到指令指针寄存器。32 位模式下，CPU 执行的指令由 EIP（指令指针寄存器）在内存中指岀。16 位模式下，由 IP 指出指令。

上述引用摘自C语言中文网

#### 1.1什么时候知道了要从内存哪里开始执行

### 2.听说还有哈佛体系结构的计算机，那么相比冯诺依曼体系结构如何，有什么特点？

### 3.经过汇编阶段产生的二进制文件为何可以链接，链接器是如何将他们链接在一起的？

### 4.冯诺依曼体系结构为什么要做分离？









