<h1 align="center">📔 C++ Prime 0x06 学习笔记</h1>

## 6.1 函数基础

* 一个典型的函数定义包括以下部分：
	* 返回类型
	* 函数名字
	* 由0个或多个形参组成的列表
	* 函数体
* 函数调用完成两项工作：隐式得用实参初始化形参；将控制权交给被调用函数，主函数的执行暂时中断
* 实参是形参的初始值，尽管实参和形参存在对应关系，但没有规定实参的求值顺序
* 形参名可选，但一般都要有。是否设置未命名的形参并不影响调用时提供的实参数量，即使某个形参不被函数使用，也必须提供一个实参

### 6.1.1 局部对象

* 名字有作用域，是程序文本的一部分，名字在其中可见
* 对象有生命周期，是程序执行过程中对象存在的一段时间
* 函数是个有名字的代码块，构成一个新的作用域，可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量，会隐藏外层作用域中同名的其他所有声明
* 函数体之外定义的对象存在于整个程序执行过程中。此类对象在程序启动时被创建，直到程序结束才销毁
* 局部变量的声明周期依赖于定义方式
	* 自动对象：普通局部变量，函数控制路径经过定义语句时创建，到达定义所在块尾销毁
	* 局部静态对象：普通变量定义成`static`类型，函数控制路径**第一次经过**定义语句时创建，**程序结束时销毁**

### 6.1.2 函数声明

* 函数声明（函数原型）可以多次，函数声明不需要函数体，用一个分号代替即可，也无需形参名字
* 函数三要素：返回类型、函数名、形参类型描述了函数的接口
* 含有函数声明的头文件应该被包含到定义函数的源文件中

### 6.1.3 分离式编译

* 分离式编译好处是如果我们修改了其中一个源文件，你们只需要重新编译那个改动了的文件即可
* 分离式编译通常会产生一个后缀为`.obj(Windows)`或`.o(UNIX)`的文件，表示对象代码
* 编译器会把对象文件链接在一起形成可执行文件



## 6.2 参数传递

* **形参初始化的机理与变量初始化一样**
* 当形参是引用类型时，实参被引用传递，引用形参是它对应实参的别名
* 当实参的值被拷贝给形参时，形参和实参是两个独立的对象，实参被值传递

### 6.2.1 传值参数

* 当初始化一个非引用类型的变量时，初始值**拷贝**给变量，变量的改动不会影响初始值
* 指针形参：可以通过拷贝指针的值，间接访问和修改所指对象的值。C++ 中建议用引用类型的形参替代指针

### 6.2.2 传引用参数

* 拷贝大的类类型或容器对象比较低效，甚至有的类型不支持拷贝（包括IO类型）
* 传引用可以避免拷贝，如果函数无需改变引用形参的值，最好声明为常量引用
* 我们可以利用引用形参返回额外信息

### 6.2.3 const 形参和实参

* 形参是 `const` 时注意顶层`const`，实参初始化形参的时候会忽略掉顶层`const`，传常量对象或者非常量对象都可以
* 因为顶层`const`会被忽略掉，所以同名函数不能被形参是否为`const`区分
* 一个普通引用必须采用**同类型**的**对象**初始化，不能使用字面值，表达式，需要转换的对象或者`const T`类型的对象
* 尽量使用常量引用：一方面避免意外修改；另一方面常量引用除了绑定常量对象还可以绑定非常量对象、字面值、一般表达式，可以处理更多实参

### 6.2.4 数组传参

* 数组不允许拷贝数组，因此我们无法以值传递的方式使用数组参数，数组会被自动转换成指针
* 因为数组以指针形式传递给函数，所以函数并不知道数组确切尺寸，所以要提供额外信息。一般管理指针形参有三种技术
	* 使用标记指定数组长度：例如字符串最后的空字符
	* 使用标准库规范：传递首元素和尾后元素指针
	* 现实传递一个表示数组大小的形参
* 数组引用形参注意加括号，注意数组引用的维度被限定了，不可以将不同维度的数组作为实参了
* `int (*matrix)[10]`和`int matrix[][10]`是等价的，注意一下后面那个形式

### 6.2.5 main: 处理命令行选项

```cpp
int main(int argc,char *argv[]){...}
int main(int argc,char* *argv){...}//等价
```

*  `argc` 表示数组中字符串个数
* `argv[]`是一个数组，元素是指向C风格字符串的指针
* `argv[0]`为程序名字，可选实参从`argv[1]`开始
* `argv[argc]`也就是最后一个指针之后的元素保证为 0

### 6.2.6 含有可变形参的函数

* 为了编写能处理不同数量实参的函数，`C++11` 新标准提供了两种主要的方案：

	* 如果所有实参类型相同，可以传递一个名为`initializer_list`的标准库类型
	* 如果实参类型不同，我们可以编写特殊函数：可变参数模板

	

`initializer_list`

* `initializer_list`和`vector`一样是一种模板类型，定义`initializer_list`必须说明所含元素的类型
* 如果想向`initializer_list`形参中传递一个值的序列，则必须把序列放在一对花括号内
* 范围`for`循环中使用`initializer_list`对象时应该常量引用类型，`initializer_list`对象的元素都是常量，无法修改

省略符形参

* 省略符形参应该仅仅用于`C`和`C++`通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝
* 省略符形参只能出现在形参列表的最后一个位置



## 6.3 返回类型和 return 语句

### 6.3.1 无返回值函数

* 返回类型 `void`
* 可以没有`return`,函数会隐式地执行`return`
* 强行令 `void `函数非那会其他类型的表达式将产生编译错误

### 6.3.2 有返回值函数

* `return` 语句返回值类型必须和函数返回值类型相同或可以隐式转换
* `C++` 无法保证返回值结果正确性，只能保证每一个`return`类型正确
* 在含有`return`语句的循环后面应该也有一条`return`语句，如果没有的话该程序就是错误的，很多编译器也检查不出来
* 返回一个值的方式和初始化变量凡是完全相同，返回的值用于初始化调用点的一个临时量，该临时量就是函数调用结果。返回值时会发生拷贝
* 如果返回引用，返回的引用对象的别名，不会真正发生拷贝
* **不要返回局部对象的引用或指针**，要想保证返回值安全，我们不妨提问：引用所引的是在函数之前已经存在的哪个对象
* 调用一个返回引用的函数得到左值，其他返回值得到右值，我们可以为返回类型是**非常量引用**的函数的结果赋值
* 函数可以返回花括号包围的值的列表
* 我们允许`main`函数没有`return`语句直接结束，编译器会隐式地插入一个`return 0`
* `main`函数不能调用自己

### 6.3.3 返回数组指针

* 因为数组不能被拷贝所以不能返回数组，但是可以返回数组的引用或指针
* 可以用类型别名简化返回数组指针或引用
* 可以使用尾置返回类型简化一个返回数组指针的函数的声明
* 如果知道返回的指针指向那个数组，可以使用`decltype关键字`声明返回类型，注意`decltype`不会将数组转为指针，`decltype`结果是个数组，所以还要在函数声明前加一个`*`符号

## 6.4 函数重载