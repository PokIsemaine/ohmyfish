<h1 align="center">📔 C++ Prime 0x03 学习笔记</h1>

## 3.1 命名空间的 using 声明

* 使用 using 声明可以免去命名空间前缀
* 每个名字都需要独立的 using 声明
* 头文件不应该包含 using 声明，如果头文件里用了 using 声明，那么引用他的文件也会用 using 声明

## 3.2 标准库类型 string

* 使用等号是拷贝初始化，不用等号是直接初始化
* cin >>读入 string 对象，string 对象会自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读起，知道遇到下一处空白
* getline会把换行符读入，但不存进 string。因为不包含换行符，所以我们有时候要手动加上换行操作符 endl 结束当前行并刷新
* string 的 size 函数返回 `string::size_type`类型，是一个无符号整数，注意不要和有符号数混用。**例如：如果n是个负的 int，那么 s.size() < n 永远为真，因为会转化为无符号整型自动取模**
* 字符串字面值对象不是 string 对象
* string 对象可以相加，string对象也可以和字符串字面值对象相加，但是必须保证每个 + 号两侧至少有一个对象是 string
* 使用基于范围的 for 语句 处理每个字符，如果要改变字符串的字符，那么必须把循环变量定义成引用类型
* 可以使用下标运算符访问某个位置的字符,如果超出范围会造成位置结果，而且由于 s.size() 是无符号整数，因此要下标的计算结果是否可能负数
* 下标访问空字符串是非法的

## 3.3 标准库类型 vector

* vector 是类模板，而不是类型
* 可以只提供 vector 对象容纳的元素数量而不用略去初始值
* 圆括号，可以说提供的值使用来构造对象的
* 花括号，想列表初始化该对象爱那个，**尽量把花括号里的值当成元素初始值的列表来处理，如果无法执行列表初始化，会考虑其他初始化方式。如果是花括号内的，又没法初始化，会考虑用这个值构造对象或者默认值初始化**
* 通常情况下，创建 vector 对象的时候直接指定容量并不会比动态添加快，甚至更慢
* 范围 for 语句体内不应改变其遍历序列的大小
* 要使用 size_type，需要首先指定它是由哪种类型定义的。vector 对象的类型总是包含着元素的类型
* 只有当元素的值可比较的时候，vector 对象才能被比较，以字典顺序比较
* vector 下标 0 到 vec.size()-1
* 不能用下标形式添加元素，只能对确知已存在的元素执行下标操作

## 3.4 迭代器介绍

* 迭代器有 begin 和 end 成员，end 成员指示的是尾元素的下一个元素。如果容器为空，begin 和 end 返回同一个迭代器，都是尾后迭代器
* 迭代器可以进行解引用操作，尾后迭代器和非法迭代器不可以
* 所有迭代器都支持 == 和 ！= 但大多数没定义 <，因此要养成迭代器和!=的习惯
* iterator 和 const_iterator 可以表示迭代器类型，begin 和 end 返回的迭代器类型由对象是否是常量决定
* 
