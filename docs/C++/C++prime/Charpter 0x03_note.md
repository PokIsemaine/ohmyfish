<h1 align="center">📔 C++ Prime 0x03 学习笔记</h1>

## 3.1 命名空间的 using 声明

* 使用 using 声明可以免去命名空间前缀
* 每个名字都需要独立的 using 声明
* 头文件不应该包含 using 声明，如果头文件里用了 using 声明，那么引用他的文件也会用 using 声明

## 3.2 标准库类型 string

* 使用等号是拷贝初始化，不用等号是直接初始化
* `cin` >>读入 `string` 对象，`string` 对象会自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读起，知道遇到下一处空白
* `getline`会把换行符读入，但不存进 `string`。因为不包含换行符，所以我们有时候要手动加上换行操作符 `endl` 结束当前行并刷新
* `string `的 `size` 函数返回 `string::size_type`类型，是一个无符号整数，注意不要和有符号数混用。**例如：如果n是个负的 int，那么 s.size() < n 永远为真，因为会转化为无符号整型自动取模**
* 字符串字面值对象不是 ``string`` 对象
* `string` 对象可以相加，``string``对象也可以和字符串字面值对象相加，但是必须保证每个 + 号两侧至少有一个对象是 `string`
* 使用基于范围的` for` 语句 处理每个字符，如果要改变字符串的字符，那么必须把循环变量定义成引用类型
* 可以使用下标运算符访问某个位置的字符,如果超出范围会造成位置结果，而且由于 s.size() 是无符号整数，因此要下标的计算结果是否可能负数
* 下标访问空字符串是非法的

## 3.3 标准库类型 vector

* `vector` 是类模板，而不是类型
* 不存在引用的 `vector`，存的得是对象
* 可以只提供` vector` 对象容纳的元素数量而不用略去初始值
* 圆括号，可以说提供的值使用来构造对象的
* 花括号，想列表初始化该对象爱那个，**尽量把花括号里的值当成元素初始值的列表来处理，如果无法执行列表初始化，会考虑其他初始化方式。如果是花括号内的，又没法初始化，会考虑用这个值构造对象或者默认值初始化**
* 通常情况下，创建 `vector` 对象的时候直接指定容量并不会比动态添加快，甚至更慢
* 范围 `for` 语句体内不应改变其遍历序列的大小
* 要使用 `size_type`，需要首先指定它是由哪种类型定义的。`vector `对象的类型总是包含着元素的类型
* 只有当元素的值可比较的时候，`vector` 对象才能被比较，以字典顺序比较
* `vector` 下标 0 到 `vec.size()-1`
* 不能用下标形式添加元素，只能对确知已存在的元素执行下标操作

## 3.4 迭代器介绍

* 迭代器有 `begin` 和` end` 成员，`end` 成员指示的是尾元素的下一个元素。如果容器为空，`begin` 和` end `返回同一个迭代器，都是尾后迭代器
* 迭代器可以进行解引用操作，尾后迭代器和非法迭代器不可以
* 所有迭代器都支持 == 和 ！= 但大多数没定义 <，因此要养成迭代器和!=的习惯
* `iterator` 和 `const_iterator` 可以表示迭代器类型，`begin` 和 `end` 返回的迭代器类型由对象是否是常量决定，`cbegin` 和 `cend` 一定会得到 `const_iterator`
* 箭头运算符把解引用和成员访问操作结合到一起
* 但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加元素
* 两个迭代器相减得到两个迭代器的距离，类型是 `difference_type` 的带符号整数。两个迭代器不能相加，注意运算顺序。
* 迭代器和下标互相转换其实就是`begin()`+下标



## 3.5 数组

* 如果不清楚元素的确切个数，请使用 `vector`
* 和内置类型一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值
* 定义数组的时候必须指定数组类型，不允许用 `auto` 关键字 由初始值的列表推断类型
* 数组的元素应为对象，不存在引用的数组
* 使用字符串字面值对字符数组初始话的时候，要记住结尾还有个空字符，所以大小至少要为显示字符数+1
* 数组不允许拷贝和赋值，有的编译器扩展支持，但这不是标准
* 要想理解数组声明的含义，最好的办法就是从数组的名字开始从内到外顺序阅读
