<h1 align="center">📔 C++ Primer 0x0F 学习笔记</h1>

## 15.1 OOP:概述

* 面向对象程序设计的核心思想是数据抽象、继承和动态绑定
	* 使用数据抽象，我们可以将类的接口与实现分离
	* 使用继承，可以定义相似的类型并对其相似关系建模
	* 使用动态绑定，可以一定程度上忽略相似类型的区别，统一的方式使用他们的对象

**继承**

* 通过继承联系在一起的类构成一种层次关系，根部的为**基类**，其他类别直接或间接继承基类称为**派生类**

* 基类负责负责定义层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员

* 对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为虚函数

	

**动态绑定**

* 通过使用动态绑定，我们能用同一段代码分别处理派生类和基类
* 当我们使用基类的引用（或指针）调用一个虚函数时，将发生动态绑定（也叫运行时绑定）



## 15.2 定义基类和派生类

### 15.2.1 定义基类

* 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此



**成员函数与继承**

* 派生类可以继承基类的成员，但是也需要对一些操作提供自己的新定义以覆盖（`override`）基类继承而来的定义
* 虚函数用来区分基类里希望派生类进行覆盖的函数和不希望派生类覆盖的函数
* 当我们用指针或引用调用虚函数时，该调用被动态绑定。根据所绑定对象类型不同，可能执行基类的版本，也可能执行某个派生类的版本
* 任何构造函数之外的非静态函数都可以是虚函数
* 关键字`virtual`只能出现在类内部的声明语句之前而不能用于类外部函数的定义
* 如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数
* 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时



**访问控制与继承**

* 派生类可以继承定义在基类的成员，但派生类的成员函数不一定有权访问从基类继承而来的成员。
* 派生类可以访问`public`和`protected`，不能访问`private`
* `protected`允许派生类访问，禁止其他用户访问





### 15.2.2 定义派生类

* 派生类必须通过使用类派生列表明确指出它从哪个（哪些）基类继承而来(`: 访问说明符 基类`)
* 派生类必须将继承来的成员函数中需要覆盖的那些重新声明
* 派生列表里访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见
* 如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分
* 大多数类都只继承自一个类（单继承）



**派生类中的虚函数**

* 派生类经常（但不总是）覆盖它继承的虚函数，如果没覆盖那就直接继承在其基类中的版本
* 派生类必须在其内部对所有重新定义的虚函数进行声明，可以在这样的函数之前加上`virtual`关键字（但不非得这么做）
* `C++11`新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表后增加一个`ovrride`关键字



**派生类对象及派生类向基类的类型转换**

* 一个派生类对象包含多个组成部分：派生类自己定义的非静态成员的子对象，基类对应的子对象
* 编译器会隐式地执行派生类到基类的转换，这意味着我们可以把派生类对象或者派生类对象的引用（指针） 用在需要基类引用（指针）的地方



**派生类构造函数**



































































