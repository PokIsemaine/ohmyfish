<h1 align="center">📔 C++ Primer 0x07 学习笔记</h1>

## 7.1 定义抽象数据类型

* 类的基本思想是数据抽象和封装
* 数据抽象是一种依赖于接口和实现分离的编程技术
* 类的接口包括用户所能执行的操作
* 类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数
* 封装实现了类的接口和实现的分离，隐藏了实现细节，类的用户只能使用接口而无法访问实现部分
* 类要实现数据抽象和封装，首先定义一个抽象数据类型，由类的设计者负责考虑类的实现过程，使用类的程序员只要抽象地思考类型做了什么，而无需了解类型的工作细节

### 7.1.1 定义抽象数据类型

* 运行程序的人是用户，类的设计者也是为用户设计并实现一个类的人，类的用户是程序员

* C++ 程序员无须刻意区分程序的用户和类的用户

### 7.1.2 定义改进的 Salses_data 类

* 定义在类内部的函数是隐式的 `inline` 函数
* 成员函数通过一个名为 `this` 的额外隐式参数来访问调用它的那个对象，当我们调用一个成员函数是，用请求该函数的对象地址来初始化 `this`
* `this` 是一个常量指针，我们不允许改变 `this` 中保存的地址
* 默认情况下 `this` 的类型是指向类类型非常量版本的常量指针，这意味着我们不能把 `this` 绑定到一个常量对象上。这也使得我们不能在一个常量对象上调用普通的成员函数
* 我们可以在参数列表后加 `const` ，将 `this` 指针声明为指向常量的指针，这有助于提高函数的灵活性
* 常量对象，以及常量对象的引用或指针都只能调用常量成员函数 （使用 `const` 的成员函数）
* 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体，因此成员函数体可以随意使用类中其他成员无须在意出现次序
* 当我们在类外部定义成员函数时，成员函数的定义必须与它的声明匹配，如果成员被声明成常量成员函数，那么定义也要在参数列表后明确指定 `const` 属性
* `return *this` 返回调用该函数的对象

### 7.1.3 定义类相关的非成员函数

* 如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件里
* IO类属于不能被拷贝类型，所以如果编写读写相关函数并使用IO类要采用引用作为参数。并且因为读写会改变流的内容，所以采用普通引用
* 执行输出内容的函数应该尽量减少对格式的控制

### 7.1.4 构造函数

* 构造函数的名字和类名相同，没有返回类型
* 构造函数不能被声明成 `const`，当我们创建类的一个 `const` 对象直到完成对象的初始化过程才真正取得其常量属性，因此构造函数在 `const` 对象的构造过程中可以向其写值
* 类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫默认构造函数，默认构造函数无须任何实参
* 编译器创建的构造函数又称合成的默认构造函数：如果存在类内的初始值，则用初始值来初始化成员；莫则，默认初始化该成员
* 某些类不能依赖于合成的默认构造函数
	* 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数
	* 含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，否则可能得到未定义的值
	* 如果包含其他类类型的成员且这个类型没有默认构造函数，那么编译将无法初始化该成员函数，我们必须自定义默认构造函数给它用
* `= default` 要求编译器生成构造函数
* 使用构造函数初始值列表来初始化
* 构造函数不应该轻易覆盖类内的初始值，除非新赋的值和原值不同。如果不能使用类内初始值，则所有构造函数都应该显示地初始化每个内置类型的成员

### 7.1.5 拷贝、赋值和析构

* 某些类不能依赖于合成的版本，当类需要分配类对象之外的资源时，合成的版本常常会失效
* 很多动态内存的类能（而且应该）使用 `vector` 对象或者 `string` 对象管理必要的存储空间，这能避免分配和释放内存带来的复杂性
* 当含有`vector`成员对象执行拷贝或赋值操作时，`vector`会设法拷贝或赋值成员中的元素。销毁时也会一次销毁`vector`中的每一个元素。这点与 `string`是非常类似的



## 7.2 访问控制与封装

* `public`说明符之后的成员在整个程序内可以被访问，`public`成员定义类的接口
* `private`说明符之后的成员可以被类的成员函数访问，但是不能使用该类的代码访问，`private`封装了类的实现细节
* 类可以包含多个`public`和`private`说明符，顺序无所谓
* 使用`class`和`struct`定义类的唯一区别就是默认的访问权限，`struct`默认所有成员是`public`，`class`默认所有成员是`private`

### 7.2.1 友元

* 友元声明让类允许其他类或函数访问它的非公有成员
* **友元的声明仅仅指定了访问权限，而非通常意义上的函数声明。我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明，通常我们把友元的声明和类本身放在同一个头文件当中**
* 一般来说，最好在类定义开始或结束前的位置集中声明友元
* 封装的两个重要优点
	* 确保用户代码不会无意间破坏封装对象的状态
	* 被封装的类的具体实现可以随时改变，无需调整用户级别的代码



## 7.3 类的其他特性

### 7.3.1 类成员再探

* 除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名
* 用来定义类型的成员(类自定义的某种类型在类中的别名）必须先定义后使用，这和普通成员有所不同，因此类型成员通常出现在类开始的地方
* 通过`mutable`关键字，使得`const`成员函数也能修改类的某个数据成员
* inline 成员函数应该与相应的类定义在同一个头文件中
* 成员函数也可以重载，只要函数之间在参数的数量和或类型上有所区别就行
* 当我们提供一个类内初始值的是，必须以符号=或者花括号表示

### 7.3.2 返回 *this 的成员函数

* `return *this`返回什么看返回类型，如果返回类型是引用那就返回引用，否则返回副本
* 一个`const`成员函数如果以引用的形式返回`*this`，那么它返回的类型将是一个常量引用
* 通过区分成员函数是否是`const`我们可以对其重载，其原因与根据指针参数是否指向`const`重载函数差不多
* 非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量函数上调用`const`成员函数，另一方面非常量对象上可以调用常量或非常量版本，但显然此时非常量版本是一个更好的匹配



### 7.3.3 类类型

* 即使两个类的成员列表完全一致，他们也是不同的类型
* 类的声明被称作前向声明，是一个不完全类型，不知道到底包含哪些成员
* **不完全类型只能在非常有些情境下使用**（令某个成员函数为友元函数的时候有用）：
	* 可以定义指向这种类型的指针或引用
	* 可以声明（但不能定义）以不完全类型作为从那树或返回类型的函数
* 对于一个类来说，我们创建对象之前，这个类必须被定义过，而不能仅仅被声明



### 7.3.4 友元再探

* 友元关系不具备传递性
* 每个类负责控制自己的友元类或者友元函数
* 要令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义彼此依赖关系
* 如果把一组重载函数声明为友元，那么需要对每个函数分别声明（看练习7.32！！！）



## 7.4 类的作用域
