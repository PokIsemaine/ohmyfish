<h1 align="center">📔 C++ Primer 0x10 学习笔记</h1>

# 16.1 定义模板

## 16.1.1 函数模板

* 模板定义以关键字`template`开始，后跟一个模板参数列表（逗号分隔，不能为空）
* 使用模板时需要指定模板实参，将其绑定到模板参数上



**模板类型参数**

* 模板类型参数前面加`typename`或`class`关键字，一般使用`typename`



**非类型模板参数**

* 模板非类型参数表示一个值而非类型，我们通过一个特定的类型名而非关键字`class`或`typename`来指定非类型参数。当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替，这些值必须是常量表达式
* 在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如指定数组大小
* 非类型模板参数的模板实参必须是常量表达式



**`inline`和`constexpr`的函数模板**

* 函数模板可以声明为`inline`或`constexpr`的，放在模板参数列表后面



**编写类型无关的代码**

* 编写泛型代码的两个重要原则
	* 模板中的函数参数是`const`的引用
	* 函数体中的条件判断仅使用`<`
* 模板程序应该尽量减少对实参类型的要求



**模板编译**

* 当编译器遇到一个模板定义时，并不生成代码，只有当我们实例化出一个模板的特定版本时，编译器才会生成代码
* 为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此与模板代码不同，模板的头文件通常既包含声明也包括定义
* 函数模板和类模板的成员函数的定义通常放在头文件这讴歌



**模板和头文件**

* 模板包含两种名字

	* 不依赖于模板参数的名字

	* 依赖于模板参数的名字

* 模板提供者保证：使用模板时，所有不依赖模板参数的名字都必须可见。当模板被实例化时，模板的定义，类模板的成员的定义也必须可见
* 模板的用户保证：用来实例化模板的所有函数、类型以及类型关联的运算符声明都是可见的
* 模板的设计这应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明
* 模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件





**大多数错误在实例化期间报告**

通常编译器会在三个阶段报告错误

* 编译模板本身(语法检查)
* 编译器遇到模板使用（检查实参数目，参数类型匹配等）
* 模板实例化（这个阶段才能发现类型相关的错误，看编译器怎么管理实例化，有可能链接时才报告）



* 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任



### 16.1.2 类模板

* 类模板是生成类的蓝图。与函数模板不同的是，编译器不能为类模板推断参数类型



**模板实例化**

* 实例化类模板需要提供显示模板实参
* 一类模板的每个实例都形参一个独立的类。类型`Blob<string>`与任何其他`Blob`类型没有关联，也不会有特殊访问权限



**在模板作用域中引用模板类型**

* 为了阅读类模板的代码，应该记住类模板的名字不是一个类型名
* 一个类模板中的代码如果使用了另一个模板，通常不将一个实际类型（或值）的名字用作其模板的参数。相反，我们通常将模板自己的参数当作被使用模板的实参



**类模板的成员函数**

* 类模板之外的成员函数必须以关键字`template`开始，后接模板参数列表
* 默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化 



**在类代码内简化模板类名的使用**

* 在类模板自己的作用域中，我们可以直接使用模板名而不提供实参
* 在类模板外定义其成员时，必须记住我们不再类作用域内，遇到类名才能进入类的作用域。由于返回类型位于类的作用域外，所以必须指出返回类型是一个实例化的类模板



**类模板和友元**

* 如果一个类模板包含非模板友元，则友元被授权可以访问所有模板实例
* 如果友元自身是模板，类可以授权给所有友元模板实例，也可以之授权给定实例

