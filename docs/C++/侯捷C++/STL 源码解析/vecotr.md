# vector

## vector 概述

首先配置一块新空间，然后将元素从旧址一一搬往新址，然后再把原来的空间释放还给操作系统



## 迭代器

`vector`维护的是一个连续线性空间，所以不论其元素型别为何，普通指针都可以作为`vector`的迭代器而满足所必要条件

`vector`迭代器支持随机存取



## 数据结构

![image-20220322143432889](https://s2.loli.net/2022/03/22/QXHcloVYwFUbtne.png)





## 构造与内存管理：constructor，push_back

所谓动态增加空间大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍来外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素并释放新空间。所以一旦重新配置，`vector`所有迭代器都失效了



### 关于扩容

简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。

仔细看下面这篇文章，讲的很详细

https://blog.csdn.net/qq_44918090/article/details/120583540

**如何避免扩容导致效率低？**

提前reserve开辟底层容量



**为什么选择倍数扩容而不是等长扩容？**

如果选择等长扩容，`push_back()`时间复杂度会变成$O(N)$

如果选择倍数扩容，倍增因子$m$，`push_back()`时间复杂度为$O(\frac {m} {m-1})$，$m$为常数，所以时间复杂度$O(1)$



**为什么选择1.5倍数扩容或者2倍方式扩容，而不是3倍、4倍扩容**

如果倍数超过过2倍（包含两倍）方式会存在空间浪费比较高的问题（内部碎片多）

使用2倍扩容机制扩容时，每次扩容的新内存大小必定大于前面的总和，无法利用之前的释放的空间。而使用1.5倍扩容是，在几次扩容以后，可以重用之前的空间了

因为stl没有严格说明要以何种方式扩容，所以不同平台不同

vs一般1.5倍扩容，因为windows堆管理系统会对释放的堆块进行合并，选1.5倍的话在多次扩容以后就可以使用之前已经释放的内存

linux一般2倍扩容，因为有伙伴系统空闲（看文章）



**那么最佳的数是多少？**

斐波那契序列方式扩容，最佳扩容因子为黄金分割数：1.618



**实际上的最佳时间？**

> 其实真正performance matters的程序，最佳实践是不要依赖这样的指数自然增长， 而是最好一开始有一个初步的估算，然后在初始化时，或者预测到大规模size增长的地方 manully的扩展其capacity。
>
> 当然performance matters的程序其实 不一定有那么多。所以，一般性的程序选择以2或1.5的指数增长，都没什么区别。
>
> Folly（Facebook C++库）是典型的支持performance matters的库，其实其内部对于performance的考虑还有很多。
>
> 
>
> 作者：李建忠
> 链接：https://www.zhihu.com/question/36538542/answer/123568463



## vector 的元素操作

### pop_back()



### erase

仔细看这篇博客https://www.cnblogs.com/chaohacker/p/13024357.html

![img](https://s2.loli.net/2022/03/22/JbzrWMedahTIFx9.png)

```cpp
for(vector<int>::iterator it = vecInt.begin(); it != vecInt.end();) {
    if(*it == 0) {
        it = vecInt.erase(it);
    } else {
        it++;
    }
}
```



### insert
