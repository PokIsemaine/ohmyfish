# hashtable

`RB-tree` 不仅在树上的平衡表现不错，在效率表现和实现复杂度上也保持相当的平衡，所以运用甚广，也成为`set`和`map`的标准底层机制

二叉搜索树具有对数平均时间的表现，但这基于输入数据有足够的随机性的假设

而`hash table`,在插入、删除、搜寻等操作上也具有常数平均时间的表现，而这种表现以统计为基础，不需仰赖输入元素的随机性

## hashtable 概述

`hash table`是个字典结构，这意味着可以提供常数时间的基本操作

`array` 太大？使用`hash function`映射到大小可接受的范围

`hash function`可能会导致碰撞问题

## 如何处理碰撞

负载系数：元素个数/表格数

### 线性探测法

$F(i)=i$

有主集团问题：平均插入成本的成长幅度远高于负载系数的成长幅度

### 二次探测法

$F(i)=i^2$

二次探测主要用来解决主集团问题，但也可能造成次集团，可以用复式散列消除

关于二次探测法的几个问题	

1. 二次探测法能够保证如果表格之中没有X,那么我们插入X一定成功？

假设表格大小为质数，而且永远保持负载系数在$0.5$以下（超过$0.5$就重新配置并重新整理表格)，那么确定没插入一个新元素所需要的探测次数不多于2

2. 二次探测法是否会在执行效率上带来太多的负面影响？

可以优化

$H_i=H_0+i^2(\mod M)$

$H_{i-1}=H_0+{(i-1)}^2(\mod M)$

整理为

$H_i-H_{i-1} = i^2-{(i-1)}^2(\mod M)$

$H_i=H_{i-1} +2i-1(\mod M)$

3. 不论线性探测或二次探测，当负载系数过高的时候，表格能够动态成长？

想要扩充表格，首先必须找出下一个新的而且够大（大约两倍）的质数，然后必须考虑表格重建的成本（rehashing），不会只是拷贝，而是完全重新来过



### 开链法（SGI STL的 `hash table`用的这种方法）

每个元素表格维护一个`list`

`hash function`为我们分配某个`list`，虽然`list`上的搜寻只能线性，但如果足够短还是够快的

表格负载系数将大于1



## hashtable 的桶子（buckets）与节点（nodes）

`buckets`聚合体：使用`vector`完成，以便有动态扩充能力

`bucket list`：并没有采用`STL`的`list`或`slist`，而是自行维护上述的`hash table node`

![image-20220321185137063](https://s2.loli.net/2022/03/21/jLXM5Jzyo9fgqKG.png)



## hashtable 的迭代器

`hashtable`迭代器必须永远维系着与整个`buckets vector`的关系，并记录目前所指节点。

* 前进操作：尝试从目前所指节点出发，前进一个位置。如果正巧是`list`的尾端，就跳到下一个`bucket`上，那正是指向下一个`list`的头部节点
* 没有后退操作（`operator--()`)
* 没有所谓的逆向迭代器（`reverse iterator`）



## hashtable 的数据结构

其中可见`buckets`聚合体以`vector`完成

虽然开链法并不要求表格大小必须为质数，但`SGI STL`还是用质数来设计，然后查找最接近并大于某数的质数



## hashtable 的构造与内存管理

有一个专属的节点配置器

### 插入与表格重整



### 判知元素的落脚处

`SGI`把找落脚点的任务封装了一层，先交给`bkt_num()`函数，再由此函数调用`hash function`，取得一个可以执行取模运算的数值。

这么做是因为有一些型别无法和直接拿来对`hashtable`的大小进行模运算，例如字符串`const char*`这时候，我们需要做一些转换

### 复制和整体删除



## hash function

`hash function`是计算元素位置的函数，对于一些整数型别（char、int、long）`hash function`什么也没做，只是忠实返回原值，但对于`const char*`就设计了一个转换函数

过时的信息：`SGI table`过去还无法处理`string,double,float`，现在可以了。如果我们现在还遇到没法处理的类型那就要自己给它们定义`hashfunction`