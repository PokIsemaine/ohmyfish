# 委托相关设计

## Observer

![image-20220203144026559](https://s2.loli.net/2022/02/03/plPzTjRiw1CKEAu.png)

![image-20220203144038445](https://s2.loli.net/2022/02/03/UlNQtoCTRai4Mn5.png)

![image-20220203144046267](https://s2.loli.net/2022/02/03/tX8BOYuSFCxymck.png)

* 应用场景：如果希望内容随着数据变化而变化，我们可以考虑采用`Observer`设计模式
* `Subject`应当提供注册、注销、通知函数（通知`Observer`来进行`update`）
* 当我们使用`OOP`时，应该考虑使用哪一些类，组织什么样的关系，来解决某一个问题（就本节例子而言，我们希望各个窗口的图表能够随着数据变化而变化，那么我们可以采用`Observer`这种设计模式来解决这个问题），因此设计模式不应该被滥用，牢记其目的是为了解决实际问题



## Composite

![image-20220203145309307](https://s2.loli.net/2022/02/03/fD4u7FVawh3Uymb.png)

`Composite` 设计模式可以考虑下面这个应用情景

> 在计算机文件系统中，有**文件夹**的概念，文件夹里面既可以放入文件也可以放入文件夹，但是文件中却不能放入任何东西。文件夹和文件构成了一种递归结构和容器结构。虽然文件夹和文件是不同的对象，但是他们都可以被放入到文件夹里，所以一定意义上，文件夹和文件又可以看作是同一种类型的对象，所以我们可以把文件夹和文件统称为目录条目，（directory entry）**.在这个视角下，文件和文件夹是同一种对象**。(也就是继承的关系 is-a)
>  所以，**我们可以将文件夹和文件都看作是目录的条目，将容器和内容作为同一种东西看待，可以方便我们递归的处理问题**，在容器中既可以放入容器，又可以放入内容，然后在小容器中，又可以继续放入容器和内容，这样就构成了容器结构和递归结构。
>  这就引出了我们本文所要讨论的composite模式，也就是组合模式，组合模式就是用于创造出这样的容器结构的。是容器和内容具有一致性，可以进行递归操作。

* 注意 C++ 容器如果要同时放不同的派生类（包括基类），那么要放指针，而不能直接放对象

## Prototype



![image-20220203150220765](https://s2.loli.net/2022/02/03/D7NGIajWJKvbOH5.png)

* 应用场景：想要创建一个继承体系，某一些子类要在未来才会出现（`classname`还没写出来）
* `Prototype`（原型设计模式）的解决方案是让子类自己去创建新的类（自己创造自己，把自己当作原型），但是要让父类能够看到新派生出来的类在哪（通过`addPrototype`放到父类）
* 每个子类有个`clone`让框架端能够看到自己的原型

![image-20220203150234775](https://s2.loli.net/2022/02/03/huxt8zBaDkXe1Iy.png)

* `static`的 `findAndClone`函数用来找原型，并在找到时调用`clone`（当然这个实现是简易的，实际可能会有数据结构或者算法的优化）
* `static`的`addPrototype`函数把新的子类放到框架中
* 有一个`static`的容器来存放原型

![image-20220203150255964](https://s2.loli.net/2022/02/03/RJoDWFvi6IbdEKA.png)

* 子类原型的自己就是第22行的`static LandSatImage _landSatImage`
* `private`的构造函数负责创建自己然后把原型加到框架里
* `protected`的构造函数（这个例子里也可以放`private`能够和默认的构造函数区分开就行，技巧是加一个没用的参数）负责`clone`被`clone`调用同时避免把副本加到框架里

![image-20220203150308622](https://s2.loli.net/2022/02/03/y1CNQnkKgdtITJj.png)

