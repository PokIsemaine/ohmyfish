# 第三章 资源管理

## 条款13: 以对象管理资源

* 获得资源后立刻放进管理对象内
	实际上"以对象管理资源的观念" 常被称为  "资源取得实际便是初始化时机"(`RAII`)，因为我们几乎总是在获得一笔资源后于同一语句内以它初始化某个管理对象。有时候获得的资源拿来赋值（而非初始化）某个管理对象，但不论哪种做法，每笔资源都在获得的同时被立刻放进管理对象中
* 管理对象运用析构函数确保资源被释放
	不论控制流如何离开去快，一旦对象被销毁，其析构函数自然会被自动调用，于是资源被释放。如果资源释放动作可能抛出异常，那就会变得棘手，为了解决这个问题，使用条款8
* 为防止资源泄漏，请使用`RAII`对象，它们在构造函数中获得资源并在析构函数中释放资源
* 两个被常用的`RAII classes`分别是`shared_ptr`和`auto_ptr`。前者通常是较佳选择，因为其`copy`行为比较只管。若选择`auto_ptr`复制动作会使它（被复制物）指向`null`



新标准一般用`weak_ptr`代替`auto_ptr`



## 条款14：在资源管理类中小心 copying 行为

* 复制 `RAII`对象必须一并复制它所管理的资源，所以资源的`copying`行为决定`RAII`对象的`copying`行为
* 普遍而常见的`RAII classed copying`行为是：抑制`copying`、施行引用计数法。不过其他行为也都可能被实现

## 条款15：在资源管理类中提供对原始资源的访问

* `APIs`往往要求访问原始资源，所以每个`RAII class`应该提供一个取得其所管理资源的办法
* 对原始资源的访问可能是经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便



## 条款16：成对使用 new 和 delete 时要采取相同形式

* 如果你在 `new `表达式中使用 `[]`,必须在想要的`delete`表达式中也使用`[]`。如果你在 `new `表达式中不使用 `[]`,必须在想要的`delete`表达式中也不使用`[]`。



## 条款17：以独立语句将 newed 对象置入智能指针

* 以独立语句将 `newed`对象存储于（置入）只能指针内。如果不这样做，一旦异常被抛出，有可能的导致难以察觉的资源泄漏
