# 第五章 实现

## 条款26：尽可能延后变量定义式的出现时间

* 尽可能延后变量定义式的出现，这样做可以增加程序的清晰程度并改善程序效率

## 条款27：尽量少做转型动作

* `const_cast`通常用来将对象的常量性转除。是唯一有此能力的 `C++-style`转型操作符
* `dynamic_cast`主要用来指向 安全向下转型，也就是用来决定某对象是否归属继承体系中的某个类型。唯一无法用旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作
* `reinterpret_cast`意图指向低级转型，实际动作取决于编译器，这也就表示它不可移植
* `static_cast`用来强迫隐式转换，大部分转换都可以做到，除了`const`转`non-const`
* 新式转换比旧式转换目的更清晰，也有利于编译器检查



* 如果可以，尽量避免转型，特别是在注重效率的代码中避免 `dynamic_cast`。如果有个设计需要转型动作，试着发展无需转型的替代设计
* 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码中
* 宁可使用新式转型，不要使用旧式转型。前者很容易辨识出来，而且也有着比较分门别类的职责

## 条款28：避免返回 handles 指向对象内部成分

* 避免返回`handles`（包括`references`、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助`const`成员函数的行为像个`const`，并将发生"dangling handles"(空悬)的可能性降至最低

## 条款29：为”异常安全“而努力是值得的

当异常被抛出时，带有异常安全的函数会

* 不泄漏任何资源
* 不允许数据败坏



异常安全函数提供下面三个保证之一

* 基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构因此而败坏，所有对象都处于一种内部前后一致的状态
* **强烈保证**：如果异常被抛出，程序状态不改变。调用这样的函数需要有这样的认知：如果函数成功，那就是完全成功；如果函数失败，程序会回复到调用函数之前的状态
* 不抛掷保证：承偌绝不抛出异常，因为它们总是能够完成它们原先承诺的功能



* 异常安全函数即使发生异常也不会资源泄漏或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型
* 强烈保证往往能够以`copy-and-swap`实现出来，但强烈保证并非对所有函数都可实现或具备现实意义
* 函数提供的异常安全保证通常最高只等于其所调用之各个函数的异常安全保证中的最弱者

## 条款30：透彻了解 inline 的里里外外

* 将大多数`inline`限制在小型、被频繁调用的函数上。这可使日后的调试和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化
* 不要只因为`function templates`出现在头文件就将它们声明为`inline`

## 条款31：将文件间的编译依存关系降至最低

* 如果对某个cpp程序的class实现文件，仅仅做了轻微修改，比如仅仅是private的某个成分，理想状态下重新编译这个程序需要很短时间，但是最后发现整个文件系统都被重新编译连接，说明“将接口从实现中分离”这件事没做好。

* 接口与实现分离的关键在于以声明的依存性替换定义的依存性，那正是编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。其他每一件事都源自于这个简单的设计策略
	* 如果使用 `object references`或`object pointers`可以完成任务，就不要使用`objects`
	* 如果能够，尽量以`class`声明式替换`class`定义式
	* 为声明式和定义式提供不同的头文件

* 设计接口类A，另一个设计为实现类AImpl，通过接口类的指针指向类的实现类，即“pointer-to-implementation"的设计方式，这时候，编译设计类A时，编译器不需要知道该为该类A的成员AImpl分配多少内存，只需分配一个指针即可；这样就实现了“接口与实现的分离”；

* 支持编译依存最小化的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是`Handle classes`和`Interface classes`
* 程序库头文件应该以"完全且仅有声明式"形式存在。这种做法无论是否涉及`templates`都适用