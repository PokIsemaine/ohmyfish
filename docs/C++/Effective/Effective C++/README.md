<h1 align="center">📔 Effective C++ 第三版 学习笔记</h1>

## 做什么

带领各位完成 《Effective C++ 》第三版的学习

多轮学习，反复阅读，不断优化更新文章



## 书本介绍



## 规划&当前进度

当前轮次：1

目标：只看标题和请记住部分

截止时间：2022/2/28

## 目录

[第一章 让自己习惯C++](/C++/Effective/Effective%20C++/第一章%20让自己习惯C++.md)

[第二章 构造/析构/赋值运算](/C++/Effective/Effective%20C++/第二章%20构造/析构/赋值运算.md)

[第三章 资源管理](/C++/Effective/Effective%20C++/第三章%20资源管理.md)

[第四章 设计与声明](/C++/Effective/Effective%20C++/第四章%20设计与声明.md)

[第五章 实现](/C++/Effective/Effective%20C++/第五章%20实现.md)

[第六章 继承与面向对象设计](/C++/Effective/Effective%20C++/第六章%20继承与面向对象设计.md)

[第七章 模板与泛型编程](/C++/Effective/Effective%20C++/第七章%20模板与泛型编程.md)

[第八章 定制 new 和 delete](/C++/Effective/Effective%20C++/第八章%20定制new和delete.md)

 [第九章 杂项讨论](/C++/Effective/Effective%20C++/第九章%20杂项讨论.md)

## 条款概览

Tip：新标准指 `C++11`

* 条款 01：视 C++ 为一个语言联邦
* 条款02：尽量以`const,enum,inline `替换` #define`
* 条款03：尽可能使用 `const`
* 条款04：确定对象被使用前已先被初始化
* 条款05：了解 C++ 默默编写并调用了哪些函数(新标准移动构造和移动赋值)
* 条款06：若不想使用编译器自动生产的函数，就该明确拒绝（新标准用`delete`）
* 条款07：为多态基类声明`virtual`析构函数
* 条款08： 别让异常逃离析构函数
* 条款09：绝不在构造和析构过程中调用 `virtual` 函数
* 条款10：令 `operator=` 返回一个 `reference to *this`
* 条款11：在 `operator=` 中处理自我赋值
* 条款12：复制对象时勿忘其每一个成分
* 条款13: 以对象管理资源 (新标准用`unique_ptr`代替`auto_ptr`)
* 条款14：在资源管理类中小心 `copying `行为
* 条款15：在资源管理类中提供对原始资源的访问
* 条款16：成对使用 `new` 和 `delete` 时要采取相同形式
* 条款17：以独立语句将 `newed` 对象置入智能指针
* 条款18：让接口容易被正确使用，不易被误用
* 条款19：设计 `class` 犹如设计 `type`
* 条款20：宁以 `pass-by-reference-to-const` 替换 `pass-by-value`
* 条款21：必须返回对象时，别妄想返回其 `reference`
* 条款22：将成员变量声明为` private`
* 条款23：宁以 `non-member`、`non-friend `替换 `member` 函数
* 条款24：若所有参数皆需类型转换，请为此采用 `non-member` 函数
* 条款25：考虑写出一个不抛异常的 `swap` 函数	
* 条款26：尽可能延后变量定义式的出现时间
* 条款27：尽量少做转型动作
* 条款28：避免返回 `handles` 指向对象内部成分
* 条款29：为”异常安全“而努力是值得的
* 条款30：透彻了解 `inline` 的里里外外
* 条款31：将文件间的编译依存关系降至最低
* 条款32：确定你的 `public `继承塑模出 `is-a `关系
* 条款33：避免遮掩继承而来的名称
* 条款34：区分接口继承和实现继承
* 条款35：考虑` virtual `函数以外的其他选择
* 条款36：绝不重新定义继承而来的 `non-virtual `函数
* 条款37：绝不重新定义继承而来的缺省参数值
* 条款38：通过复合塑模出 `has-a` 或根据某物实现出
* 条款39：明知而审慎地使用` private `继承
* 条款40：明智而审慎地使用多重继承
* 条款41：了解隐式接口和编译期多态
* 条款42：了解` typename` 的双重含义
* 条款43：学习处理模板化基类内的名称
* 条款44：将与参数无关的代码抽离` templates`
* 条款45：运用成员函数模板接受所有兼容类型
* 条款46：需要类型转换时请为模板定义非成员函数
* 条款47：请使用 `traits classes` 表现类型信息
* 条款48：认识 `template `元编程
* 条款49：了解 `new-handler` 的行为
* 条款50：了解 `new` 和 `delete` 的合理替换时机
* 条款51：编写 `new` 和 `delete` 时需固守常规
* 条款52：写了 `placement new` 也要写 `placement delete`
* 条款53：不要轻忽编译器的警告
* 条款54：让自己熟悉包括 `TR1` 在内的标准程序库
* 条款55：让自己熟悉 `Boost`