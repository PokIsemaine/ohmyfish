# 第七章 模板与泛型编程

## 条款41：了解隐式接口和编译期多态

* `classes`和`templates`都支持接口`interfaces`和多态`polymorphism`
* 对`classes`而言接口是显式的，以函数签名为中心。多态则是通过`virtual`函数发生于运行期
* 对`template`参数而言，接口是隐式的，基于有效表达式。多台则通过`template`具现化和函数重载解析发生于编译期



## 条款42：了解 typename 的双重含义

* 声明`template`参数时，前缀关键字`class`和`typename`可互换
* 请使用关键字`typename`标识嵌套从属类型名称；但不得在基类列或者成员初值列内把它作为`base class`修饰符



## 条款43：学习处理模板化基类内的名称

* 可在`derived class templates`内通过`"this->"`指涉 `base class templates`内的成员名称，或藉由一个明白写出的`base class` 资格修饰符完成



## 条款44：将与参数无关的代码抽离 templates

* `Templates`生成多个`classes`和多个函数，所以任何`template`代码都不该与某个造成膨胀的`template`参数产生相依的关系
* 因非类型模板参数而造成的代码膨胀，往往可以消除，做法是以函数参数或`class`成员变量替换`template`参数
* 因类型参数造成的代码膨胀往往可以降低，做法是让带有完全相同二进制表述的局限类型共享实现码



## 条款45：运用成员函数模板接受所有兼容类型

* 请使用成员函数模板生成可接受所有兼容类型的函数
* 如果你声明 `member templates`用于泛化拷贝构造或泛化赋值操作，你还是需要声明正常的拷贝构造函数和拷贝赋值操作符



## 条款46：需要类型转换时请为模板定义非成员函数

* 当我们编写一个`class template`而它所提供之 “与此`template`相关的” 函数支持 “所有参数之隐式类型转换”时，请将那些函数定义为`class template`内部的友元函数

## 条款47：请使用 traits classes 表现类型信息

* `Traits`并不是`C++`关键字或者头文件，它是一种技术，也是一个共同遵循的协议。这项技术要求之一是，他对内置类型和用户自定义类型的表现必须一样好

要设计并实现一个 `traits class`

* 确认若干你希望将来可取的类型相关信息
* 为该信息选择一个名称
* 提供一个`template`和一组特化版本，内含你希望支持的类型相关信息

如何使用一个 `traits class`

* 建议一组重载函数或函数模板，彼此间的差异只存在于各自的`traits`参数。令每个函数实现码与其接受之`traits`信息相应和
* 建议一个控制函数或函数模板，它调用上述那些函数并传递`traits class`所提供的信息



* `Traits classes`使得类型相关信息在编译期可用。它们以`templates`和`templates 特化`实现
* 整合重载技术后，`traits classes`有可能在编译期对类型执行`if else`测试



## 条款48：认识 template 元编程

* `Template metaprogramming`（TMP，模板元编程）可将工作由运行期移往编译器，因而得以实现早期错误侦测和更高的执行笑了
* TMP 可被用来生产基于政策选择组合的客户定义代码，也可用来避免生产对某些特殊类型并不适合的代码