# 第四章 设计与声明

## 条款18：让接口容易被正确使用，不易被误用

* 好的接口容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质
* "促进正确使用"的办法包括接口的一致性，以及与内置类型的行为兼容
* "阻止误用"的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任
* `shared_ptr`支持定制型删除器。这可防范`DLL`问题，可被用来自动接触互斥锁



所谓的`cross-DLL problem`：这个问题发生于"对象在动态链接程序库`DLL`中被`new`创建，却在另一个`DLL`内被`delete`销毁"。在许多平台上这类跨`DLL`之`new/delete`成对运用会导致运行时错误



## 条款19：设计 class 犹如设计 type

`Class`的设计就是`type`的设计。

如何设计高效的`classes`？首先必须了解你面对的问题，你的回答往往会导致你的设计规范：

* **新 `type`的对象应该如何被创建和销毁？**
	构造函数、析构函数、内存分配函数、内存释放函数

* **对象的初始化和对象的赋值有什么样的差异？**
	构造函数、赋值操作符，注意区分初始化和赋值

* **新 `type`的对象如果被 `passed by value`意味着什么？**
	拷贝构造函数

* **什么是新`type`的合法值？**

	成员函数（特别是构造函数、赋值操作符、工具函数）必须进行的错误检查，以及函数抛出的异常
	

* **你的新`type`需要配合某个继承图系吗？**

	是否将函数设为`virtual`
	

* **你的新`type`需要什么样的转换？**
	类型转换函数，构造函数是否`explicit`

* **什么样的操作符和函数对此新`type`而言是合理的？**

	声明哪些函数，哪些应该是成员函数
	

* **什么也的标准函数应该驳回？**

	哪些应该设为 delete
	

* **谁该取用新`type`的成员？**
	`public`、`private`、`protected`、友元的设置

	

* **什么是新`type`的未声明的接口？**

	

* **你的新`type`有多一般化？**
	或许你其实并非定义一个新`type`而是一整个`types`家族。果真如此你应该定义一个新的`class template`



* **你真的需要一个新`type`吗？**

	如果只是定义新的派生类以便为既有的`class`添加机能，那么说不定单纯定义一个或多个非成员函数或模板更能够达到目标



## 条款20：宁以 pass-by-reference-to-const 替换 pass-by-value

* 尽量以 `pass-by-reference-to-const` 替换 `pass-by-value`。前者通常比较高效，并可避免切割问题
* 以上规则并不适用于内置类型，以及`STL`的迭代器和函数对象。对它们而言，`pass-by-value`往往比较恰当



## 条款21：必须返回对象时，别妄想返回其 reference

* 绝不要返回`pointer`或`reference`指向一个`local stack`对象，或返回一个`reference`指向一个`heap-allocated`对象，或返回`pointer`或`reference`指向一个`local static`对象而有可能同时需要多个这样的对象



## 条款22：将成员变量声明为 private

* 切记将成员变量声明为`private`。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件得到保证，并提供`class`作者以充分的实现弹性
* `protected`并不比`public`更具封装性



## 条款23：宁以 non-member、non-friend 替换 member 函数

* 宁以 `non-member`、`non-friend `函数替换 `member` 函数。这样做可以增加封装性、包裹弹性和机能扩充性



## 条款24：若所有参数皆需类型转换，请为此采用 non-member 函数

* 如果你需要为某个函数的所有参数（包括被`this`指针所指的那个隐式参数）进行类型转换，那么这个函数必须是个`non-member`



## 条款25：考虑写出一个不抛异常的 swap 函数

* 当 `std::swap` 对你的类型效率不高时，提供一个`swap`成员函数，并确定这个函数不抛出异常
* 如果你提供一个`member swap`也应该提供一个`non-member swap`来调用前者。对于`classes`，也请特化`std::swap`
* 调用`swap`时应针对`std::swap`使用`using`声明式，然后调用`swap`并且不带人呢和命名空间资格修饰
* 为用户定义类型进行`std templates`特化是好的，但千万不要尝试在`std`内加入某些对`std`而言全新的东西