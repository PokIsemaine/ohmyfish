# 第3章 传输层

## 3.1 概述和传输层服务

### 传输服务和协议

传输层向上提供的服务：进程与进程之间 以报文 message 为单位的 逻辑通信

逻辑通信：看起来两个远程应用之间通过 socket API 直接通信了，实际上还是要一层层传过去的



TCP 把上面传下来的 message 下来分成若干 segment ，借助网络层提供的服务传到远程的对等 TCP 实体（具体如何做，可以看后面的网络层，目前先假设网络层提供这样的服务），然后 TCP 再把分散的 segment 拼接成 message



TCP 是流的协议，保证流是正常的，不保证报文的界限，需要应用层来标识哪里是开始哪里是结束

[tcp的传输过程是可靠的，那为什么许多较大的下载最终还要校验文件完整性？](https://www.zhihu.com/question/532373054/answer/2493042170)



有多个传输层可供选择：TCP 和 UDP



![image-20220606230120473](https://s2.loli.net/2022/06/06/9d5huHwFsJaB2ly.png)



### 传输层 vs 网络层

传输层向上提供的服务相较网络层向上提供的服务做了加强

网络层（IP）提供的服务：丢失、乱序、延迟

传输层（TCP）可以弥补网络层的不足，向上层提供可靠的服务 RDT



传输层还提供了在源端复用 TCP 实体并在目标端 解复用的重要功能，这是网络层不具备的。

实际上就是传输层相比网络层做了更细的划分，网络层是主机到主机，传输层是进程到进程



注意有些东西是 TCP 加强不了的 TCP 并不能降低延迟、也不能提升带宽

TCP 本身不保证安全性，不过可以使用 SSL 来保证安全性

![image-20220606231428334](https://s2.loli.net/2022/06/06/TtNczH3Ip26DryE.png)

### Internet 传输层

![image-20220606231843673](https://s2.loli.net/2022/06/06/Az2HgyjRZ8YKeGV.png)



## 3.2 多路复用和解复用

先前提到多路复用和解复用实际上就是传输层在网络层基础上的进一步细分：从主机到主机细分为进程到进程



![image-20220606233151475](https://s2.loli.net/2022/06/06/tiGuOQndwW5l6Ps.png)



### 多路复用解复用工作原理

那么如何区分同一主机的不同进程呢？这正是解复用要做的。

主机联合使用 IP 地址和端口号将报文段发送给合适的套接字



![image-20220607083715362](../../../../../../.config/Typora/typora-user-images/image-20220607083715362.png)



关于端口 https://zhuanlan.zhihu.com/p/280672302



### 无连接的多路解复用

2元组：目标 IP ， 目标端口号

两个不同源 IP 地址/源端口号的数据报具有相同的目标 IP 和端口号就会被定位到相同的套接字

![image-20220607085337760](../../../../../../.config/Typora/typora-user-images/image-20220607085337760.png)



### 面向连接的多路解复用

TCP 4 元组：源 IP，目标 IP，源端口号，目标端口号

任意一项不同就会被定位到不同的套接字

![image-20220607085057778](../../../../../../.config/Typora/typora-user-images/image-20220607085057778.png)

为什么 TCP 要四元组 https://blog.csdn.net/yxg520s/article/details/121379245



### 面向连接的多路复用：多线程 Web Server

![image-20220607085548114](https://s2.loli.net/2022/06/07/ne8F2jlIOzd9cB6.png)

连接套接字与进程之间并非总是有着一一对应的关系



## 3.3 无连接传输 UDP

UDP : User Datagram Protocol  用户数据报协议

尽力而为 = 能搞就搞，搞不定拉到

![image-20220607090019649](../../../../../../.config/Typora/typora-user-images/image-20220607090019649.png)



### UDP：用户数据报协议

为什么要使用 UDP

* 无连接减少延迟
* 头部小只有八字节（源端口号、目的端口号、长度、校验和）开销小，TCP 的话有二十字节，开销要大很多
* 由于没有拥塞控制和流量控制：应用 message 往下传输的速率和主机到网络中的传输速率基本是一致的（下图 V1=V2）上面来多快，下面就发多快，不考虑对方还有网络堵不堵



![image-20220607091354467](../../../../../../.config/Typora/typora-user-images/image-20220607091354467.png)



这些特性使得 UDP 很适合一些实时性的应用



![image-20220607090558046](../../../../../../.config/Typora/typora-user-images/image-20220607090558046.png)





### UDP 校验和

![image-20220607091613412](../../../../../../.config/Typora/typora-user-images/image-20220607091613412.png)

如果校验失败会直接被丢弃



**通过校验不等于没有差错**：残存错误

接收方校验实际上是校验：校验和是否和字段内容匹配

如果校验和与字段内容同时出错但又恰好匹配，那么错误的数据就会通过校验



UDP 校验和保护的范围不止是数据部分，还会包含 UDP 的头部以及一些 IP 尾部



![image-20220607092742799](../../../../../../.config/Typora/typora-user-images/image-20220607092742799.png)



![image-20220607093130714](../../../../../../.config/Typora/typora-user-images/image-20220607093130714.png)



## 3.4 可靠数据传输的原理

可靠数据传输：RDT

可靠数据传输可以在不同层实现，而 TCP 只是传输层可靠数据传输的典型代表，了解原理可以帮助我们快速学习其他层可靠数据传输的实现



rdt 问题的复杂性：要向上层提供可靠的服务，然而依赖的服务却并不可靠

> 映射到现实里其实就是中间管理层的难处啦。团长（当前层）要向师长（上层）保证坚决完成任务（提供可靠服务），然而团长（当前层）下面的连长（依赖层）表示会尽力而为（提供尽力而为的、不可靠的服务）



### 可靠数据传输：问题描述

![image-20220607094449753](../../../../../../.config/Typora/typora-user-images/image-20220607094449753.png)

我们的方法论如下：

* 渐进式地开发：逐个把假设去掉，逐步接近真实情况，然后增加机制对抗不可靠性
* 只考虑单向数据传输：双向的数据传输实际上就是 2 个单向数据传输问题的综合
	* 不过要记住控制信息是双向流动的（会有一些反馈信息）
* 使用有限状态机 FSM 来描述发送方和接收方



### Rdt 1.0：在可靠信道上的可靠数据传输

假设：信道完全可靠，不出错、不丢失

发送方：

1. **接收**上层调用来的数据单元
2. 将上层数据单元**封装**为本层的数据单元
3. **发送**本层的数据单元

接收方：

1. **接收**下层调用来的数据单元
2. 将下层数据单元**解封装**为本层的数据单元
3. **发送**本层的数据单元



> rdt 1.0 映射到现实就是连长很能干，团长啥都不用干



![image-20220607095422693](../../../../../../.config/Typora/typora-user-images/image-20220607095422693.png)



### Rdt 2.0：具有比特差错的信道

假设：信道不会丢失，但可能出现比特差错



![image-20220607100148717](../../../../../../.config/Typora/typora-user-images/image-20220607100148717.png)

> rdt2.0 可以类比老师给学生讲题：老师讲一遍题，学生反馈懂没懂。
>
> 学生懂了，那就跟老师反馈懂了。然后学生开始做这题，老师开始等待下一题。
>
> 学生没懂，就和老师反馈没懂，老师接收到没懂的反馈后重新讲一遍题并和先前一样等待学生的反馈



![image-20220607101057170](../../../../../../.config/Typora/typora-user-images/image-20220607101057170.png)







![image-20220607101945493](../../../../../../.config/Typora/typora-user-images/image-20220607101945493.png)

### Rdt2.0 的致命缺陷！-> Rdt 2.1

![image-20220607102541346](../../../../../../.config/Typora/typora-user-images/image-20220607102541346.png)



rdt2.0 已经考虑了 packet 出错的可能，那么如果 ACK 或者 NAK 出错呢

![image-20220607102248909](../../../../../../.config/Typora/typora-user-images/image-20220607102248909.png)



为了应对 ACK 或者 NAK 可能出现问题的情况，rdt 2.1 引入了新的机制：识别不了反馈就重发并且给分组加序号

简单来说就是如果受到了莫名奇妙的反馈那就把原来的 package 重发一遍，这有可能造成重复，所以我们对分组进行编号这样可以把受到的重复分组丢掉了



![image-20220607103249352](../../../../../../.config/Typora/typora-user-images/image-20220607103249352.png)

发送方处理出错的 ACK/NCK

![image-20220607103808408](../../../../../../.config/Typora/typora-user-images/image-20220607103808408.png)

接收方处理出错的 ACK/NAK

![image-20220607103915158](../../../../../../.config/Typora/typora-user-images/image-20220607103915158.png)