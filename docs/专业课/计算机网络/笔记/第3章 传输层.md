# 第3章 传输层

## 3.1 概述和传输层服务

### 传输服务和协议

传输层向上提供的服务：进程与进程之间 以报文 message 为单位的 逻辑通信

逻辑通信：看起来两个远程应用之间通过 socket API 直接通信了，实际上还是要一层层传过去的



TCP 把上面传下来的 message 下来分成若干 segment ，借助网络层提供的服务传到远程的对等 TCP 实体（具体如何做，可以看后面的网络层，目前先假设网络层提供这样的服务），然后 TCP 再把分散的 segment 拼接成 message



TCP 是流的协议，保证流是正常的，不保证报文的界限，需要应用层来标识哪里是开始哪里是结束

[tcp的传输过程是可靠的，那为什么许多较大的下载最终还要校验文件完整性？](https://www.zhihu.com/question/532373054/answer/2493042170)



有多个传输层可供选择：TCP 和 UDP



![image-20220606230120473](https://s2.loli.net/2022/06/06/9d5huHwFsJaB2ly.png)



### 传输层 vs 网络层

传输层向上提供的服务相较网络层向上提供的服务做了加强

网络层（IP）提供的服务：丢失、乱序、延迟

传输层（TCP）可以弥补网络层的不足，向上层提供可靠的服务 RDT



传输层还提供了在源端复用 TCP 实体并在目标端 解复用的重要功能，这是网络层不具备的。

实际上就是传输层相比网络层做了更细的划分，网络层是主机到主机，传输层是进程到进程



注意有些东西是 TCP 加强不了的 TCP 并不能降低延迟、也不能提升带宽

TCP 本身不保证安全性，不过可以使用 SSL 来保证安全性

![image-20220606231428334](https://s2.loli.net/2022/06/06/TtNczH3Ip26DryE.png)

### Internet 传输层

![image-20220606231843673](https://s2.loli.net/2022/06/06/Az2HgyjRZ8YKeGV.png)



## 3.2 多路复用和解复用

先前提到多路复用和解复用实际上就是传输层在网络层基础上的进一步细分：从主机到主机细分为进程到进程



![image-20220606233151475](https://s2.loli.net/2022/06/06/tiGuOQndwW5l6Ps.png)



### 多路复用解复用工作原理

那么如何区分同一主机的不同进程呢？这正是解复用要做的。

主机联合使用 IP 地址和端口号将报文段发送给合适的套接字



![image-20220607083715362](https://s2.loli.net/2022/06/08/glWyxFAQEtHkJnY.png)



关于端口 https://zhuanlan.zhihu.com/p/280672302



### 无连接的多路解复用

2元组：目标 IP ， 目标端口号

两个不同源 IP 地址/源端口号的数据报具有相同的目标 IP 和端口号就会被定位到相同的套接字

![image-20220607085337760](https://s2.loli.net/2022/06/08/BlbDwjkIy3aCKve.png)



### 面向连接的多路解复用

TCP 4 元组：源 IP，目标 IP，源端口号，目标端口号

任意一项不同就会被定位到不同的套接字

![image-20220607085057778](https://s2.loli.net/2022/06/08/ml6wdyM2DeScorz.png)

为什么 TCP 要四元组 https://blog.csdn.net/yxg520s/article/details/121379245



### 面向连接的多路复用：多线程 Web Server

![image-20220607085548114](https://s2.loli.net/2022/06/08/uNCDaVP4vHGI3nQ.png)

连接套接字与进程之间并非总是有着一一对应的关系



## 3.3 无连接传输 UDP

UDP : User Datagram Protocol  用户数据报协议

尽力而为 = 能搞就搞，搞不定拉到

![image-20220607090019649](https://s2.loli.net/2022/06/08/pwr96G5SYeMnk32.png)



### UDP：用户数据报协议

为什么要使用 UDP

* 无连接减少延迟
* 头部小只有八字节（源端口号、目的端口号、长度、校验和）开销小，TCP 的话有二十字节，开销要大很多
* 由于没有拥塞控制和流量控制：应用 message 往下传输的速率和主机到网络中的传输速率基本是一致的（下图 V1=V2）上面来多快，下面就发多快，不考虑对方还有网络堵不堵



<img src="https://s2.loli.net/2022/06/08/6PczYJ8VKmQLRop.png" alt="image-20220607091354467" style="zoom:80%;" />



这些特性使得 UDP 很适合一些实时性的应用



![image-20220607090558046](https://s2.loli.net/2022/06/08/rtovVPaz7kjUe1T.png)





### UDP 校验和

![image-20220607091613412](https://s2.loli.net/2022/06/08/IGlrTYsK7bz4muP.png)

如果校验失败会直接被丢弃



**通过校验不等于没有差错**：残存错误

接收方校验实际上是校验：校验和是否和字段内容匹配

如果校验和与字段内容同时出错但又恰好匹配，那么错误的数据就会通过校验



UDP 校验和保护的范围不止是数据部分，还会包含 UDP 的头部以及一些 IP 尾部



![image-20220607092742799](https://s2.loli.net/2022/06/08/4DCyqV1LN7Inuha.png)



<img src="https://s2.loli.net/2022/06/08/8cb4igOEUd9Mp72.png" alt="image-20220607093130714" style="zoom:80%;" />



## 3.4 可靠数据传输的原理

可靠数据传输：RDT

可靠数据传输可以在不同层实现，而 TCP 只是传输层可靠数据传输的典型代表，了解原理可以帮助我们快速学习其他层可靠数据传输的实现



rdt 问题的复杂性：要向上层提供可靠的服务，然而依赖的服务却并不可靠

> 映射到现实里其实就是中间管理层的难处啦。团长（当前层）要向师长（上层）保证坚决完成任务（提供可靠服务），然而团长（当前层）下面的连长（依赖层）表示会尽力而为（提供尽力而为的、不可靠的服务）



### 可靠数据传输：问题描述

![image-20220607094449753](https://s2.loli.net/2022/06/08/3wDU4MRWA6O8FbQ.png)

我们的方法论如下：

* 渐进式地开发：逐个把假设去掉，逐步接近真实情况，然后增加机制对抗不可靠性
* 只考虑单向数据传输：双向的数据传输实际上就是 2 个单向数据传输问题的综合
	* 不过要记住控制信息是双向流动的（会有一些反馈信息）
* 使用有限状态机 FSM 来描述发送方和接收方



### Rdt 1.0：在可靠信道上的可靠数据传输

假设：信道完全可靠，不出错、不丢失

发送方：

1. **接收**上层调用来的数据单元
2. 将上层数据单元**封装**为本层的数据单元
3. **发送**本层的数据单元

接收方：

1. **接收**下层调用来的数据单元
2. 将下层数据单元**解封装**为本层的数据单元
3. **发送**本层的数据单元



> rdt 1.0 映射到现实就是连长很能干，团长啥都不用干



![image-20220607095422693](https://s2.loli.net/2022/06/08/9Modc8IQSFRzPfr.png)



### Rdt 2.0：具有比特差错的信道

假设：信道不会丢失，但可能出现比特差错



![image-20220607100148717](https://s2.loli.net/2022/06/08/x5MfnEdbuCPABZT.png)

> rdt2.0 可以类比老师给学生讲题：老师讲一遍题，学生反馈懂没懂。
>
> 学生懂了，那就跟老师反馈懂了。然后学生开始做这题，老师开始等待下一题。
>
> 学生没懂，就和老师反馈没懂，老师接收到没懂的反馈后重新讲一遍题并和先前一样等待学生的反馈



![image-20220607101057170](https://s2.loli.net/2022/06/09/ARkCHxF6PaiwYQu.png)







![image-20220607101945493](https://s2.loli.net/2022/06/08/O5GjsWvIkordRPH.png)

### Rdt2.0 的致命缺陷！-> Rdt 2.1

![image-20220607102541346](https://s2.loli.net/2022/06/08/SrC36JayBpiLIHO.png)



rdt2.0 已经考虑了 packet 出错的可能，那么如果 ACK 或者 NAK 出错呢

![image-20220607102248909](https://s2.loli.net/2022/06/08/NHpOTqulbsrdv4G.png)



为了应对 ACK 或者 NAK 可能出现问题的情况，rdt 2.1 引入了新的机制：识别不了反馈就重发并且给分组加序号

简单来说就是如果受到了莫名奇妙的反馈那就把原来的 package 重发一遍，这有可能造成重复，所以我们对分组进行编号这样可以把受到的重复分组丢掉了



![image-20220607103249352](https://s2.loli.net/2022/06/08/H3dIlTLoY7ywmSP.png)

发送方处理出错的 ACK/NCK

![image-20220607103808408](https://s2.loli.net/2022/06/08/xaipsVjrO6JqTAn.png)

接收方处理出错的 ACK/NAK

![image-20220607103915158](https://s2.loli.net/2022/06/08/qb7KAxXt5yVg2NC.png)



发送方

* 在分组中加入序列号，**两个序列号(0,1)就够了，因为目前还是停等协议**（发送方发送一个分组， 然后等待接收方的应答，一次只发送一个未经确认 的分组）
* 必须检测 ACK/NAK 是否出错（需要 EDC）
* 状态数变成了两倍，必须记住当前分组的序列号为0还是1

接收方

* 必须检测接收到的分组是否重复，状态会指示希望接收到 0 还是 1
* 接收方并不知道发送方是否正确接收到了ACK/NAK，没有安排确认的确认，因为这样会无限套娃（确认的确认的确认……），接收方通过发送方后续的行为表现来判断

![image-20220608225550524](https://s2.loli.net/2022/06/08/v86UXiM4qmSeJFT.png)

### Rdt 2.2 无 NAK 的协议

![image-20220608230115389](https://s2.loli.net/2022/06/08/5gc2DLQ8TliwmGt.png)



> 女："你觉得我漂亮吗？"
>
> rdt2.1 版本男："你不漂亮" 
>
> rdt2.2 版本男："你很温柔"
>
> 理解这个对话就能理解 rdt2.2 的实质：巧妙地回答 否定含义
>
> 由此可见 rdt2.1 是低情商版本，rdt2.2 是高情商版本





原来的每次一个 ACK 需要对应一个 NACK

| ACK0 | ACK1 | ACK2 | ……   |
| ---- | ---- | ---- | ---- |
| NAK0 | NAK1 | NAK2 |      |

但实际上对于 ACK1 而言其对应的 NAK1 和 ACK0 是等价的，同理

ACK0 = NAK1，ACK1 = NAK2，……

也就是说我们可以用前一个的 ACK 代替当的 NAK



![image-20220608230414166](https://s2.loli.net/2022/06/08/w3Uxd1v8QWe65cR.png)

![image-20220608231531199](https://s2.loli.net/2022/06/08/nwAxUhokjPTzJly.png)



红色为和 rdt2.1 不同的地方

![image-20220608231546846](https://s2.loli.net/2022/06/08/CkFR4d2Ums1EnhJ.png)



### Rdt3.0：具有比特差错和分组丢失的信道

新的假设：下次信道可能会丢失分组（数据或 ACK）

这会造成死锁的情况（见下图，只是展现了数据丢了的情况，ACK 也会丢的）

![image-20220608232332688](https://s2.loli.net/2022/06/08/e67kjyN958xSn3V.png)

当前的机制：检验和、序列号、ACK、重传，这还处理不了这种情况，我们需要新机制：超时重传！



![image-20220608233247444](https://s2.loli.net/2022/06/08/RyTGrwh3eZl9ozY.png)



那么如何设置合理的 timeout 时间呢？（具体可以看 TCP 超时时间设置）

在数据链路层两个网卡中间的一段链路，如果延迟分布比较集中，那么可以设为一个确定的时间

如果两台主机（传输层）经过了很多路由器连接，网卡延迟变化比较大，那么就自适应地去算 timeout



![image-20220608234702983](https://s2.loli.net/2022/06/09/tBujSYxA3neUO62.png)





状态机

![image-20220609195344131](https://s2.loli.net/2022/06/09/jXS9MNIdkhTqOw2.png)



rdt3.0 的运行

一般来讲 timeout 的设置是大于正常接收 ACK 时间的，但是如果 timeout 设置不合理造成过早超时，那么 rdt3.0 的效率会降低，一半的分组是重复的

![image-20220609195730152](https://s2.loli.net/2022/06/09/ouGwtET7WanvOml.png)





| 可靠数据传输 | 假设 | 机制 |
| ------------ | ---- | ---- |
| rdt1.0       |      |      |
| rdt2.0       |      |      |
| rdt2.1       |      |      |
| rdt2.2       |      |      |
| rdt3.0       |      |      |



rdt3.0 的性能问题：停-等操作的 rdt3.0 会在链路容量比较大的情况下产生性能问题

> 这就好比从浙江到哈尔滨有一条很宽很长的高速公路，停等操作相当于这条路每次只能通行一辆车，一辆车可能要很久很久才能到达，到达的信息返回又要很久很久，这就造成了极大的浪费。这是协议本身的问题

![image-20220609201150261](https://s2.loli.net/2022/06/09/i1q6RwOBDzt7Lao.png)





### 流水线协议

如何增加利用率？一次发多个并且现在要好几个编号了，这就是流水线技术

![image-20220609212001184](https://s2.loli.net/2022/06/09/mrGNOtUz93iSVFW.png)



停等协议适合局域网、链路容量比较小的情况。在链路容量比较大的情况下可以采用流水线技术，流水线技术一次发送多个未确认的分组，解决了协议瓶颈提高了利用率并无限接近 100%，再提升很难了，现在瓶颈变为了链路带宽



为了实现流水线技术需要一些新东西

* 必须增加序号的范围：用多个 bit 表示分组的序号（原来只要 1 位 bit 即可）
* 在发送方/接收方要有缓冲区（why？）
	* 发送方缓冲：未得到确认，可能需要重传
	* 接收方缓冲：上层用户取数据的速率和接收到的数据速率不同；接收到的数据可能会乱序，排序交付



### 滑动窗口协议

在了解通用的流水线协议（回退N步和选择重传协议）之前先来了解一下 通用的滑动窗口协议

根据缓冲区（窗口）大小可以对滑动窗口协议进行如下划分，其中 GBN 和 SR 是两种通用的流水线协议

| 协议         | 发送窗口 | 接收窗口 |
| ------------ | -------- | -------- |
| 停止等待协议 | =1       | =1       |
| 回退N步 GBN  | >1       | =1       |
| 选择重传 SR  | >1       | >1       |

