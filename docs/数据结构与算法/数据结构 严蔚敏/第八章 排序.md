# 第八章 排序

## 基本概念

* 稳定性：若$K_i=K_j$，排序前$R_i$领先于$R_j$，如果排序后$R_i$还是领先于$R_j$，那么就是稳定的。所有待排序记录中，只要有一组不符合，那么就是不稳定
* 根据排序时记录占用的存储设备分为内部排序（内存）和外部排序（量很大，要访问外存）
* 使有序区中记录树木增加一个或几个的操作称为一趟排序
* 内部排序分类，根据扩大记录有序序列长度的原则不同分类
	* 插入类：无序子序列中的记录插入到有序子序列中，**直接插入排序，折半插入排序，希尔排序**
	* 交换类：通过交换无序序列中记录得到关键字最大（最小）的记录，放到有序序列中，**冒泡排序，快速排序**
	* 选择类：无需序列中选择关键字最大（最小）的记录，加入到有序序列当中，**简单选择排序，树形选择排序，堆排序**
	* 归并类：通过归并两个或多个记录的有序子序列，**2-路归并排序**
	* 分配类：**唯一一类不需要进行关键字之间比较的排序**，只要利用分配和收集实现，**基数排序**
* 待排序记录的存储方式
	* 顺序表：记录次序关系由存储位置决定，需要移动数据
	* 链表：记录次序关系由指针决定，不要移动数据，改指针即可
	* 待排序记录本身存储在一组地址连续的存储单元中，同时有一个存储记录存储地址的向量。排序不移动记录本身，移动地址向量中记录的地址，称为地址排序
* 排序算法效率的评价指标
	* 执行时间，关键字之间的比较和记录的移动，还有初始状态（不过本书假定是随机的）
	* 辅助空间，除了存放待排序记录占用空间之外执行算法需要的其他存储空间。理想为$O(1)$，也就是和数据量无关

## 插入排序

插入排序的基本思想：每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置，直到所有待排序记录插入为止

按照寻找插入位置的方法分为：直接插入排序，折半插入排序和希尔排序

### 直接插入排序

* 顺序查找法
* 在**一趟**插入排序中
	* 最好情况（正序），比较一次，不移动；
	* 最坏情况（逆序）比较i次，移动 i+1 次
* 总共，需要执行 n-1 趟排序。
	* 最好情况总的比较次数达到最小值 n-1 次，不需要移动
	* 最坏情况总的关键字比较次数 $KCN=\sum_{i=2}^ni=(n+2)(n-1)/2$ 和记录移动次数 $RMN=\sum_{i=2}^n(i+1)=（n+4)(n+1)/2$ 均达到最大值
* 时间复杂度 $O(N^2)$
* 空间复杂度 $O(1)$
* 稳定排序
* 也适用于链式结构，单链表上无需移动记录，只要修改相应指针
* 更适合与基本有序的情况

### 折半插入排序

* 折半查找法，**只适用于顺序结构，不能用于链式结构**
* **关键字比较次数**和待排序序列的初始排列无关，**只依赖于记录的个数**
* 插入第i个记录需要经过 $\lfloor log_2i \rfloor+1$ 次比较
* 记录正序或接近正序的时候直接插入排序比折半插入排序比较次数少，但是平均性能来说折半查找性能更好
* 对象移动次数和直接插入一样，依赖于对象初始序列
* 时间复杂度 $O(N^2)$
* 空间复杂度 $O(1)$
* 稳定排序
* 适合初始记录无序，N较大的情况

### 希尔排序

* 缩小增量排序，记录跳跃式移动，不稳定
* 分组插入，减少参与直接插入排序的数据量
* 时间复杂度，看增量序列，目前只有一些局部结论
* 空间复杂度 $O(1)$
* 只能用于顺序结构，不能用于链式结构
* 增量序列中的值应该没有除 $1$ 以外的公因子，并且最后的增量值必须等于 $1$
* 记录的总比较次数和移动次数都比直接插入排序要少，$N$ 越大，越无序，效果越明显

## 交换排序

基本思想：两两比较待排序记录的关键字，不符合次序要求时进行交换

### 冒泡排序

* 两两比较待排序记录的关键字，不符合次序要求时进行交换
* 时间复杂度 $O(N^2)$
	* 最好情况（初始为正序）只要进行一趟排序，$n-1$ 次关键字比较
	* 最坏情况（初始为逆序）要进行 $n-1$ 趟排序，$KCN=\sum_{i=n}^2(i-1)=n(n-1)/2$，$RMN=3\sum_{i=n}^2(i-1)=3n(n-1)/2$
* 稳定排序
* 可以用于链式结构
* 移动记录次数多的时候比直接插入排序差，不适合初始无序和 $N$ 较大的情况

### 快速排序

* 优化：一次交换消除多个逆序
* 快速排序趟数取决于递归树的深度
* 时间复杂度$O(Nlog_2N)$
	* 最好情况（划分为长度大致相等的子表），$O(Nlog_2N)$
	* 最坏情况（基本有序），递归树变成单支树，必须要n-1趟才能将所有记录定位，$KCN=\sum_{i=1}^{n-1}(n-i)=n(n-1)/2$，合理选枢轴可以避免
* 空间复杂度：最大递归调用次数和递归树深度一致
	* 最好$O(log_2N)$
	* 最坏$O(N)$

* 不稳定
* 适用于顺序结构，很难用于链式
* N 较大，平均情况下，内部排序，快排最快，适合无序，N较大的情况

## 选择排序

基本思想：每趟从待排序记录中选出关键字最小的记录，按顺序放记录最后面

### 简单选择排序

* 时间复杂度 $O(N^2)$
	* 记录移动次数较少，最好情况（正序）不移动，最坏情况（逆序）移动 $3(n-1)$次
	* 无论初始排列如何，$KCN=\sum_{i=1}^{n-1}=n(n-1)/2$
* 空间复杂度$O(1)$
* 选择排序本身是稳定的，但是交换的策略可能导致表现出不稳定现象
* 可用于链式存储结构
* 记录移动次数较少，每当一记录占用空间较多的时候，比直接插入排序快

### 树形选择排序

* 减少简单选择排序关键词比较

* 锦标赛排序思想，两两比较选出最小
* 辅助存储空间较多，最大值继续多余比较
* 时间复杂度 $O(Nlog_2N)$

### 堆排序

* 是一种树形选择排序
* 完全二叉树
* 时间复杂度$O(Nlog_2N)$，最坏也是这个，这个比快排好
* 空间复杂度$O(1)$
* 不稳定排序
* 只能顺序结构和，不能用于链式结构
* 初始建堆所需的比较次数较多，记录较少时不宜



## 归并排序

归并排序：两个或两个以上有序表合并成一个有序表

* 稳定排序
* 可用于链式结构不需要附加存储空间，但递归实现时仍需要开辟相应的递归工作栈
* 时间复杂度 $O(Nlog_2N)$
	* n 个记录时，需要$\lceil log_2N \rceil$趟归并排序
	* 每趟归并排序，关键词比较次数不超过 $N$,元素移动次数都是$N$
* 空间复杂度 $O(N)$



## 基数排序

* 分配类排序，不需要比较关键字大小，根据关键字各位的值进行分配与收集
* 多关键字排序两种方法：最高位优先法，**最低位优先法（基数排序）**
* 如果有d个关键字，每个关键字可能有rd个取值，那么从最低位开始分配到rd个队列中再采集，重复d次完成排序
* 基是指rd的范围
* 时间复杂度 $O(d(N+rd))$
	* 每一趟分配时间复杂度 $O(N)$
	* 每一趟收集时间复杂度 $O(rd)$
	* d 趟排序
* 空间复杂度 $O(n+rd)$
	* 2rd 个队列指针
	* n个指针域空间
* 稳定排序
* 可用于链式结构，也可以用于顺序结构
* 要知道各级关键字主次关系和取值范围

## 外部排序

待排序数据很大，没法一次性调入内存，整个排序过程必须用外存分批调入内存



* 采用归并排序的思想

* $$
	外部排序总时间=内部排序时间(m \cdot t_{IS})+外存信息读写的时间(d \cdot t_{IO})+内部归并所需时间(s\cdot ut_{mg})
	$$

* 提高外排效率主要靠减少外存信息读写次数 d

* 读写外存次数和归并的趟数成正比，对 m 个初始归并段进行 k 路平衡归并时，归并趟数 $s=\lceil log_k m \rceil$ 

* 为了减少 s，要么增加归并段个数 k （多路平衡归并），要么减少初始归并段个数 m （置换选择方法）

* 多路平衡归并

	*  k 不是越大越好，单纯增加 k 会导致内部归并时间 $ut_{mg}$ 增加
	* 利用败者树优化

* 置换-选择排序

	* 基于树形选择排序，在整个排序过程中，选择最小（最大）关键字和输入、输出、交叉或平行进行