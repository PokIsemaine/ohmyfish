## 第3章 栈和队列

栈和队列都是限制存取点的线性结构，只能在首或者尾进行插入删除操作

### 栈

仅在表尾进行插入或删除操作的线性表

先进后出FILO或者后进先出LIFO

1～n合法序列数量为$\frac {C_{2n}^n}{n+1}$

#### 顺序栈

地址连续

栈顶元素是top-1对应的

#### 链栈



#### 双向栈

栈满判断，两个栈的长度之和=栈空间长度的大小（栈顶相遇），不要记结论容易死。做学习通和算法设计第一题看自己能不能写对

#### 递归

递归：若一个函数，过程，数据结构的定义内部直接或间接出现定义本身的应用，就称他为递归的

递归过程的应用：问题的定义是递归的f(n)=n*f(n-1),数据结构是递归的比如“链表，问题的解法是递归的比如汉诺塔

递归工作栈：栈顶为工作记录，包括参数，局部变量，上一层的返回地址

递归时间复杂度的求解

任何递归算法都可以改写成非递归算法

### 队列

先进先出FIFO

#### 普通队列

约定Q.r指示**队尾后一个位置**，Q.f指示队头位置,初始Q.f=Q.r=0

空队列条件:Q.f==Q.r

存在问题：Q.f!=0,Q.r=M，再有元素入队发生假溢出

解决方案:每次出队剩余元素向下移动，但这样浪费时间。我们可以使用循环队列来处理假溢出问题，但是要注意循环队列同样存在溢出问题因为空间有限

#### 循环队列

循环队列，把队列想成环形，q[0]接在q[M-1]后面，取模实现

区分空队列和满队列：

对于循环队列，空队列和满队列条件都是Q.rear==Q.front, 没法区分是哪种情况。下面给出三种解决方案

少用一个存储空间

引入一个标志变量标记是否非空和是否非满

使用计数器



求循环队列长度:(Q.rear-Q.front+M)%M

队伍满: (Q.rear+1)%M==Q.front

队伍空：Q.rear=Q.front

#### 链队

一个链队需要两个分别只是队头和队尾的指针才能唯一确定、

出队：链队出队后也需要判空，但是要记住链队出队后需要释放队头元素所占的空间，同时当队列中最后一个元素被删后，队列尾指针也丢了，因此需要对队尾巴指针重新赋值（指向头节点）

队头元素:Q.front->next->data，Q.front不是直接指向队头元素的



### 算法设计

1.将编号为0和1的两个栈存放于一个数组空间V[m]中，栈底分别处于数组的两端。当第0号栈的栈顶指针top[0]=-1时栈空，当第1号栈的栈顶指针top[1]=m时栈空，两个栈从两边向中间生长。编写双栈初始化，判断栈空，栈满，进栈和出栈等算法的函数

```c++
int isEmpty(DblStack S,int i){
	return S.top[i]==S.bot[i];   
}

int isFull(Dblstack S){
    return S.top[0]+1==S.top[1];
}

Status Init(DblStack &S,int m){
    S.V = new SElemType[m];
    S.top[0]=S.bot[0]=-1;
    S.top[1]=S.bot[1]=m;
    return OK;
}

Status Push(DblStack &S,SElemType x,int i){
    if(S.top[0]+1==S.top[1])return ERROR;
    if(i==0)S.V[++S.top[0]]=x;
    else S.V[--S.top[1]]=x;
    return OK;
}

void Pop(DblStack &S,SElemType &x,int i){
    if(S.top[i]==S.bot[i])return ERROR;
    if(i==0)x=S.V[S.top[0]--];
    else x=S.V[S.top[1]++];
    return OK;
}
```

2.用栈进行字符串回文判断

```c++
int IsPalindrome(char *t){
	InitStack(S);
	int len=strlen(t);
	int i=0;
	for(i=0;i<len/2;i++)Push(S,t[i]);
	if(len%2==1)i++;
	while(!EmptyStack(S)){
		x=Pop(S);
		if(x!=t[i])return 0;
		else i++;
	}
	return 1;
}
```

3.输入整数序列，用栈存储输入的整数，如果整数不等于-1,就进栈，否则输出栈顶整数并出栈。算法应对异常情况给出信息

```c++
void InOutS(int S[]){
	top=0;
    for(int i=1;i<=n;i++){
        cin>>x;
        if(x!=-1){
            if(top==MAXSIZE-1){
                puts("栈满");
                exit(0);
            }
            else S[++top]=x;
        }
        else{
            if(top==0){
                puts("栈空");
                exit(0);
            }
           	else cout<<"栈顶元素"<<S[top--]<<endl; 
        }
    }
}
```

4.从键盘上输入一个后缀表达式，是编写算法计算表达式的之。规定逆波兰式长度不超过1行，以$作为输入结束，操作数之间空格分开，操作符只有+-*/

```c++
void Postfix(){
	InitStack(OPND);
	num=0.0;
	ch=getchar();
	while(ch!='$'){
		int i=0;
		while((ch>='0'&&ch<='9')||ch=='.'){
			data[i++]=ch;
			ch=getchar();
		}
		num=atof(data);
		Push(OPND,num);
		switch(ch){
			case:' ':break;
			case:'+':Pop(OPND,b);Pop(OPND,a);Push(OPND,a+b);
			case:'-':Pop(OPND,b);Pop(OPND,a);Push(OPND,a-b);
			case:'*':Pop(OPND,b);Pop(OPND,a);Push(OPND,a*b);
			case:'/':Pop(OPND,b);Pop(OPND,a);Push(OPND,a/b);
		}
		ch=getchar();
	}
	return GetTop(OPND);
}
```

5.假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，称可以操作的序列为合法序列，否则称为非法序列

```c++
bool Judge(char A[]){
	int check=0;
	for(int i=0;A[i];i++){
		if(A[i]=='I')check++;
        else check--;
        if(check<0)return 0;
	}
	if(check!=0)return 0;
	return 1;
}
```

6.假设以带头节点的循环链表表示队列，并且只设一个指针指向队尾元素节点（注意，不设头指针），试编写相应的置空队列，判断队列是否为空，入对和出队等算法

```c++
typedef struct QNode{
	QElemType data;
	struct QNode *next;
}QNode,*QueuePtr;
typedef struct{
	QueuePtr rear;
}LinkQueue;

void InitQueue(LinkQueue &Q){
    Q->rear=Q->rear->next;
    while(Q->rear!=Q->rear->next){
        s=Q->rear->next;
        Q->rear->next=s->next;
        delete s;
    }
}
int EmptyQueue(LinkQueue &Q){
    return Q->rear->next->next==Q->rear->next;
}
Status EnQueue(LinkQueue &Q,QElemType e){
    p = new QueueNode;
    p->data = e;
    p->next = Q->rear->next;
    Q->rear->next=p;
    Q->rear=p;
    return OK;
}
Status DelQueue(LinkQueue &Q,QElemType e){
    if(Q->rear->next->next==Q->rear->next)return ERROR;
    p = Q->rear->next->next;
    e = p->data;
    Q->rear->next=p->next;
    delete p;
}
```

7.假设以数组Q[m]存放循环队列中的元素，同时设置一个标志tag,以tag\==0和tag\==1来区别front==rear时是空还是满，编写插入和删除算法

```c++
typedef struct {
    QElemType *base;
    int front,rear,tag;
}SeQueue;

Status InitQueue(SeQueue &Q){
    Q.base = new QElemType[M];
    Q.front=Q.rear=Q.tag=0;
    return OK;
}

Status EnQueue(SeQueue &Q,QElemType e){
    if(Q->tag==1&&(Q.front==Q.rear))return ERROR;
    Q.base[Q.rear]=e;
    Q.rear=(Q.rear+1)%M;
    if(Q.tag==0)Q.tag=1;
    return OK;
}

Status DelQueue(SeQueue &Q,QElemType &e){
    if(Q->tag==0&&(Q.front==Q.rear))return ERROR;
   	e=Q.base[Q.front];
    Q.front=(Q.front+1)%M;
    if(Q->tag==1)Q->tag=0;
    return OK;
}
```

8.如果允许在循环队列的两端都可以进行插入和删除的操作，写出循环队列的类型定义，从队尾删除和从队头插入的算法

```c++
typedef struct{
    QElemType *base;
    int front,rear;//front为队头元素的前一个元素，rear为队尾元素的后一个元素
}SeQueue;

Status EnQueue(SeQueue &Q,QElemType e){
    if(Q.rear==(Q.front-1+M)%M)return ERROR;
    Q[Q.front]=e;
    Q.front=(Q.front-1+M)%M;
    return OK;
}

Status DelQueue(SeQueue &Q,QElemType &e){
    if(Q.rear==Q.front)return ERROR;
    e=Q.[Q.rear];
    Q.rear=(Q.rear-1+M)%M;
    return OK;
}
```



9.写出Ack(m,n)函数的递归算法和非递归算法

```c++
#include <iostream>
#include <tuple>
using namespace std;
using LL = long long;
// n = 0 --> n + 1
//
// Ack(n - 1 , Ack(n , m - 1))
struct Node {
  LL m, n;
  LL stat = -1;
  Node *Next;
};
struct Stack {
  Node *Top = NULL;
  int sz = 0;
  bool Is_Empty() { return sz == 0; }
  void pop() {
    Node *T = Top;
    Top = Top->Next;
    delete T;
    sz--;
  }
  void push(int m, int n, int stat) {
    Node *T = new Node;
    T->n = n, T->m = m, T->stat = stat;
    T->Next = Top;
    Top = T;
    sz++;
  }
  tuple<LL, LL, LL> top() { return {Top->m, Top->n, Top->stat}; }
  void print() {
    Node *T = Top;
    while (T != NULL) {
      int x = T->m;
      int y = T->n;
      int z = T->stat;
      cerr << x << ' ' << y << ' ' << z << '\n';
      T = T->Next;
    }
    cerr << '\n';
  }
};
LL ACK(int m, int n) {//递归
  if (m == 0) return n + 1;
  if (n == 0) return ACK(m - 1, 1);
  return ACK(m - 1, ACK(m, n - 1));
}
LL Ack(int m, int n) {//非递归
  Stack S;
  S.push(m, n, -1);
  LL res = 0;
  while (!S.Is_Empty()) {
#ifdef DEBUG
    S.print();
#endif
    auto [m, n, stat] = S.top();
    S.pop();
    if (m == 0) {
      res = n + 1;
      continue;
    }
    if (n == 0) {
      S.push(m - 1, 1, -1);
      continue;
    }
    if (stat == -1) {
      stat = res;
      S.push(m, n, stat);
      S.push(m, n - 1, -1);
      continue;
    }
    S.push(m - 1, res, -1);
  }
  return res;
}
int main() {
  cout << ACK(3, 4) << '\n';
  cout << Ack(3, 4) << '\n';
  return 0;
}

```

10.已知f为单链表的表头指针，链表中存储的都是整型数据，试写出实现下列运算的递归算法

求链表中的最大整数

求链表的节点个数

求所有整数的平均值

```c++
int GetMax(LinkList p){
	if(!p->next)return p->data;
    else{
        int max=GetMax(p->next);
        return p->data>max?p->data:max;
    }
}

int GetLength(Linklist p){
    if(!p->next)return 1;
    else{
		return GetLength(p->next)+1;
    }
}

int GetAve(Linklist p,int n){
    if(!p->next)return p->data;
    else{
		double ave=GetAve(p->next,n-1);
        return (ave*(n-1)+p->data)/n;
    }
}
```

## 