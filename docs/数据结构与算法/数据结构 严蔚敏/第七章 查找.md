# 第7章 集合（查找表）

## 基本概念

关键字：用于表示一个数据元素

主关键字：可以唯一地标识一个数据元素的关键字

次关键字：用以表示若干记录的关键字，基于主关键字的查找结果唯一

查找表的存储：线性表，索引结构，二叉树，哈希表

存储方式的选择：考虑查找，增加，删除的效率

查找表的主要操作：查找，增加和删除元素

查找方法的评价：查找速度，占用存储空间，算法本身复杂度，平均查找长度$ASL=\sum_{i=1}^np_ic_i$

## 线性表查找算法

### 顺序查找

$ASL=\frac {n+1} {2}$

优点：简单适用广，不用管是否有序

缺点：ASL 大

### 折半查找

只能用于顺序存储的**有序表**，不适合经常变动的

判定树：描述查找过程的二叉树，只与表记录个数n相关，与关键字取值无关

比较次数不超过判定树的深度：$\lfloor log_2n \rfloor+1$

$ASL=\frac {(n+1)log_2(n+1)}{n}-1$  约等于  $log_2(n+1)-1$

### 分块查找

又称索引序列查找

$ALS_{bs}=L_b+L_w$

$L_b$ 为所在块的平均查找长度

$L_w$ 为块中元素的平均查找长度

块的大小为 $\sqrt N$ 最合适



如果线性表既要快速查找又经常动态化，则可用分块查找

缺点是增加索引表的存储空间并对初始索引表排序



## 树表的查找

### 二叉排序树

左子树不为空，左子树上所有结点小于他根节点的值

右子树不为空，右子树上所有结点大于他根节点的值

左右子树也都是二叉排序树

中序遍历一棵二叉排序树可以得到结点递增的有序序列

平均查找长度和二叉树形状有关，如果蜕变的成单支树，深度为n,平均查找长度就变成了$\frac {n+1} 2$

二叉排序树有利于维护有序性



插入$O(log_2N)$

创建$O(Nlog_2N)$

删除$O(log_2N)$

查找，如果数据有序$O(N)$，如果结构和里$O(log_2N)$

### 平衡二叉树AVL

左右子树深度差绝对值不超过 1

左右子树都是平衡二叉树

平衡因子 BF ：-1,0,1



调整方法：找到离插入结点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为最小不平衡子树
LL 型，RR 型，LR 型，RL 型

首先，记住这四个不同的型号，然后我来靠诉你怎么处理容易错的那部分（AB旋转后在下面剖离出来的子树给谁的问题）
这玩意不用记，看我为你们录制的视频



<iframe height="720" width="1080" wai t> </iframe>

### B-树

适用于文件很大且放于外存的查找

B-树 是平衡多叉树

应用于磁盘中的目录管理，数据库系统中的索引组织



一棵 m 阶的 B-树，或为空树，或为满足下列特性的m叉树

* 树中的每个结点至多有 m 棵子树
* 若根节点不是叶子结点，则至少有两棵子树
* 除根之外的所有非终端结点至少有 $\lfloor m/2\rfloor$ 棵子树
* 所有的叶子结点出现在同层次（体现平衡），不带任何信息，称为失败结点（实际不存在）
* 所有的非终端结点最多有 m-1 个关键字
* 任一关键字 $K_i$ ，$P_{i-1}$ 指向左子树，$P_i$ 指向右子树
* B-树 具有平衡、有序、多路的特点



B-树 查找

包含两种基本操作：在 B-树 中查找结点(磁盘），在结点中查找关键字（内存）

磁盘上查找时间>内存上查找时间

在磁盘上进行查找的次数，即查找关键字结点在 B- 树上的层数，是决定B-树查找效率的首要因素

在含有 N 个关键字的 B- 树上查找时，从根到关键字所在结点的路径上涉及的结点个数不超过 $log_{\lceil m/2\rceil}{\frac {N+1} 2}+1$



### B+树

B+树 是 B-树 的变形，更适合文件索引系统

B+树 和 B-树 的差异如下

* 有 n 棵子树的结点含有 n 个关键字
* 所有的叶子结点包含了全部关键字的内容，以及指向这些关键字记录的指针，且叶子结点本身依关键字的大小自小到大顺序链接
* 所有非终端结点可以看作索引部分，结点中仅含有子树（根节点）中的最大（最小）关键字



查找：

* 可以对B+树进行两种查找，一种从最小关键字起顺序查找，另一种从根节点开始随机查找
* B+树不仅能够有效地查找单个关键字，更适合查找某个范围内所有关键字



插入：

* 只在叶子结点插入

* 结点关键字个数>m就分裂，分别包含$\lfloor \frac {m+1} 2\rfloor$和$\lceil \frac {m+1} 2\rceil$,双亲结点应该同时包含两个的最大关键字

	

删除：

* 只在叶子结点进行



## 散列表的查找

散列查找法：对元素的关键字值进行某种运算，直接求出元素的地址

不是基于比较的查找，查找速度和表的长度基本没啥关系

术语

* 散列函数和散列地址：$p=H(key)$，p为散列地址，H为散列函数
* 散列表：一个**有限连续**的存储空间，按照散列函数村
* 冲突和同义词：不同的关键字通过散列函数得到相同的散列地址，那么就是冲突。这些不同关键词是对该散列函数来说是同义词



### 散列函数的构造

通常考虑下面要素

* 散列表的长度
* 关键字的长度
* 关键字的分布情况
* 计算散列函数的所需的时间
* 记录的查找效率



好的散列函数

* 函数计算阶段，每个关键字只有一个散列地址与之对应
* 函数的值域要在表长范围内，分布尽量均匀，尽可能减少冲突



#### 常见构造方法

* 数字分析法：事先必须明确知道所有的关键字每一位上各种数字的分布情况
* 平方取中法：
	* 取关键字平方后的中间几位或组合作为散列地址，具体所取的位数由表长决定
	* 适合不能事先了解关键字的所有情况或难以从关键字中找到取值较分散的几位

* 折叠法：
	* 将关键字分割成位数相同的及部分（最后一部分可以不同），然后取基本法叠加和（舍去进位）作为散列地址
	* 有移位叠加和边界叠加两种
	* 适合散列地址位数较少，关键字位数较多，且难于直接从关键字中取值分散的几位

* 除留余数法：$H(key)=key%p$，假设散列表长为m,选一个不大于m的数p,用p去除关键字，p一般为小于表长的最大质数



### 处理冲突的办法

按照组织形式不同，分为开放地址法和链地址法



**开放地址法：寻找下一个空的散列地址（探测）**

$H_i=(H(key)+d_i)%m$

$d_i$为增量序列，根据增量序列的不同分为下面三种探测方法

* 线性探测法：

​	$d_i=1,2,……,m$

​	把散列表想成循环表，总能找到一个不发生冲突的，如果找不到就是满了，要做溢出处理
​	会产生二次聚集

* 二次探测法：

​	$d_i=1^2,(-1)^2,2^2,(-2)^2,3^2,(-3^2),……,k^2,(-k)^2$

​	$k<=m/2$

​	可以避免二次聚集，但是不能保证找到不发生冲突的地址

* 伪随机探测法

	$d_i=伪随机数序列$

	可以避免二次聚集，但是不能保证找到不发生冲突的地址

​	

二次聚集：处理冲突中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象



**链地址法**

同义词接在相同的链表里

### 散列表查找

由于冲突的产生，还是要比较的，所以还是要看 ASL

比较关键词的个数取决于：散列函数，冲突处理方法，散列表的装填因子

装填因子$\alpha = \frac {表中填入的记录数} {散列表的长度}$，越大发生冲突可能性越大，需要比较关键字越多

散列函数好坏也影响冲突出现频繁程度，一般认为均匀的散列函数，对同一组随机数字产生冲突的可能性相同。**所以如果散列函数均匀，那么影响ASL的因素只有冲突处理方案和装填因子**



| 处理冲突的办法           | 查找成功ASL                        | 查找失败ASL                            |
| ------------------------ | ---------------------------------- | -------------------------------------- |
| 线性探测法               | $\frac 1 2 (1+\frac 1 {1-\alpha})$ | $\frac 1 2 (1+\frac 1 {(1-\alpha)^2})$ |
| 二次探测法，伪随机探测法 | $-\frac 1 \alpha ln(1-\alpha)$     | $\frac 1 {1-\alpha}$                   |
| 链地址法                 | $1+\frac \alpha 2$                 | $\alpha +e^{-\alpha}$                  |

可以发现ASL和表长无关



链地址法平均查找长度小于开放地址法，链地址法无需实现确定表的容量，插入和删除操作也容易实现

$ASL_{succ}=\frac 1 n \sum_{i=1}^n C_i$ ,其中n为散列表记录个数

$ASL_{unsucc}=\frac 1 r \sum_{i=1}^n C_i$，其中n为散列表函数取值个数

