## 第4章 串，数组，广义表

### 串

#### 基本概念

* 串是一个有穷的字符序列
* 空格串：由空格字符组成的串，**长度非空**，区分空串
* 串的长度：串中所含的字符个数
* 子串和主串：字符串s1中任意个**连续的字符**组成的子序列s2被成为是s1的子串，而s1是s2的主串，长度为n的字符串有$n*(n-1)/2+n$个子串
* 相等：两个串的长度相等，并且对应位置字符相等
* 特殊性体现在内容受限，字符串的每个数据元素只能为一个字符
* 模式匹配：求S2在S1中首次出现的位置运算

#### 串的表示和实现

**顺序**

* 用一组连续的存储单元依次存储串中的字符序列

* 以一个特殊字符（\0）作为字符串结束表示

**链式**

* 每个结点一个字符的单链表表示法
* 每个结点多个字符的块链存储表示（改进方法，优化存储效率）
* $存储密度=\frac {串值所占的存储单元}{实际分配的存储单元}$
* 单链表表示法的缺点是存储效率比较低，可以每个结点村多个字符，既提高了存储效率，又保留了链表的灵活性



#### **模式匹配**

**朴素匹配：**

最坏情况每次比较都在最后出现不等，最多比较 $n-m+1$ 趟，总比较次数 $m*（n-m+1)$

一般情况下 $m<<n$ 因此时间复杂度 $O(m*n)$



科普：实际情况下模式匹配很多都是朴素算法实现的，因为真实数据比较随机，在大多数情况下朴素效果优于 KMP（kmp还需要预处理）C++ string 的find方法也是基于比较暴力的朴素匹配而非 KMP



**首尾模式匹配算法：**

针对朴素匹配最坏情况每次比较都在最后出现不等的特点，先比较首和尾字符然后比较中间的，没什么用



**无回溯的模式匹配：KMP**

匹配过程过一遍，要能手推

* KMP 算法的优点：不需要回溯，可以边读边匹配，所以主串匹配位置的指针不会变小
* 无回溯匹配是时间复杂度 $O(n)$ ,预处理 next 数组复杂度 $O(m)$  ,总复杂度 $O(n+m)$
* 失配的时候主串匹配指针不移动


### 数组

#### 基本概念

* 元素为线性表的线性结构，**元组的结构相同**，元素类型相同
* 数组逻辑上是线性结构的推广，是特殊的线性表
* 可以看作下标和值的偶对的集合
* 是一种逻辑结构（线性结构）

#### 存储

元素个数固定，不用插入删除移动，**适合**用顺序存储

**顺序存储**

基本都是求位置之类的

代入三个数据求解这个方程即可$ai+bj+c=k$，求出a、b、c就ok了

有时候再加上最开始元素地址就行

#### 矩阵的压缩存储

二维数组也称为矩阵，行列数相同的矩阵称为方阵

* 多个值相同的元素分配一个存储空间，对零元素不分配空间
* 稀疏矩阵压缩后，必会失去随机存取的功能
* 对特殊矩阵压缩的主要目的是减少不必要的存储空间



**对称矩阵**

特征：$a_{ij}=a_{ji}$

压缩：$n^2$元素到$n(n+1)/2$空间

a[1,n]\[1,n]压到b[0,n(n+1)/2-1]

以行为主序，下三角元素存到向量中：
$$
k=\left\{
\begin{matrix}
 i(i-1)/2+j-1 ,(i>=j)\\
 j(j-1)/2+i-1,(i<j)
\end{matrix}
\right.
$$


**三角矩阵**

可以看作对称矩阵一半

以行为主序，下三角元素存到向量中：

$$k=i(i-1)/2+j-1$$



**对角矩阵**

特征：所有非零元素集中在以主对角线为中心的带状区域

以三对角矩阵为例

总共$$(n-2)*3+2*2=3n-2$$个元素

a[1,n]\[1,n]压缩存入b[0,3n-3]
$$
k=\left\{
\begin{matrix}
 3(i-1)-1(主对角线左下角i=j+1)\\
 3(i-1)-1,(主对角线上i=j)\\
 3(i-1)+1(主对角线右上角i=j-1)
\end{matrix}
\right.\\
\\
综上:k=2(i-1)+j-1
$$
其实还是解方程  $ai+bj+c=k$ 就ok了

**稀疏矩阵**



特征：非零元素相比零元很少，而且分布无规律

压缩：只存储矩阵的行列维数和每个非零元的行列下标以及值



**顺序存储**

三元表所需存储单元：$3(t+1)$其中：t为非0元个数，下标为0的三元组存储行列数和非零元的个数

**求转置矩阵**

**一般矩阵转置算法**：两层for循环行列对称赋值，$O(mn)$



对于系数稀疏矩阵主要：行列维数呼唤，每个三元组的i和j相互调换，重排三元组次序即可

**方法一：按M的列序转置**

$O(M的列数*非零元个数t)$，若t与mxn同级，$O(mn^2)$

注意是M的列数，不是n



**方法二：快速转置**

设两个数组

num[col]表示矩阵M中第col列非零元素个数

cpot[col]表示M中第col列第一个非零元在mb中的位置

$O(M的列数+非零元的个数t),若t与m\cdot n同级，O(mn)$





**链式存储**

带行指针向量的单链表表示，需要存储单元$3t+m$

十字链表法，设行指针数组和列指针数组，分别指向每行列的第一个非零元，$O(ts),s=max(m,n)$





### 广义表

#### 基本概念

* 线性表的推广
* **元素结构可以不同**,$a_i$可以是原子也可以是广义表
* 广义表是递归定义的
* 广义表的深度：展开后括号的层数
* 难以用顺序存储结构，通常用链式存储结构（头尾链表存储结构和扩展线性链表存储结构）



#### 运算

空表的话不能做下面两个运算了

取表头：表的第一个元素，任何一个非空元素广义表的表头一定是表中第一个元素**可以是原子也可以是子表**

取表尾：除去表头外，有其余元素构成的表，任何一个非空元素广义表的表尾**一定是子表**



区分()和(())

