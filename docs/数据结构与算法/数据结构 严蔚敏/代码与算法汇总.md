# 代码与算法汇总

## 线性表

1.两个递增有序表合并程一个递增有序表,不能重复

```c++
void MergeList(LinkList &La,Linklist &La,LinkList &Lc){
    pa=La->next;
    pb=Lb->nextl
    Lc=pc=La;
    while(pa&&pb){
        if(pa->data<pb->data){
            pc->next=pa;
            pc=pa;
            pa=pa->next;
        }
        else if(pa->data>pb->data){
            pc->next=pb;
            pc=pb;
            pb=pb->next;
        }
        else{
            pc->next=pa;
            pc=pa;
            pa=pa->next;
            q=pb->next;
            delete pb;
            pb=q;
        }
    }
    pc->next=pa?pa:pb;
    delete Lb;
}
```

2.两个非递减有序链表合并为一个非递增有序链表

```c++
void MergeList(LinkList &La,Linklist &La,LinkList &Lc){
    pa=La->next;
    pb=Lb->nextl
    Lc=pc=La;
    Lc->next=NULL;
    while(pa||pb){
    	if(!pa){
    		q=pb;
    		pb=pb->next;
    	}
    	else if(!pb){
    		q=pa;
    		pa=pa->next;
    	}
    	else if(pa->data<=pb->data){
    		q=pa;
    		pa=pa->next;
    	}
    	else{
    		q=pb;
    		pb=pb->next;
    	}
    	q->next=Lc->next;Lc->next=q;
    }
    delete Lb;
}
```

3.已知两个链表A和B分别表示两个集合，其元素递增排列，求交集放在A链表中

```c++
void Intersection(LinkList &La,Linklist &Lb,Linklist &Lc){
	pa=La->next;
    pb=Lb->nextl
    Lc=pc=La;
    while(pa&&pb){
    	if(pa->data==pb->data){
    		pc->next=pa;
 			pc=pa;
 			pa=pa->next;
 			u=pb;pb=pb->next;delete u;
    	}
    	else if(pa->data<pb->data){
    		u=pa;pa=pa->next;delete u;
    	}
    	else{
    		u=pb;pb=pb->next;delete u;
    	}
    }
    while(pa){
    	u=pa;pa=pa->next;delete u;
    }
    while(pb){
    	u=pb;pb=pb->next;delete u;
    }
    pc->next=NULL;
    delete Lb;
}
```

4.已知两个链表A,B元素递增排列，求A-B差集，并返回集合元素个数

```c++
void Difference(Linklist &La,Linklist &Lb,int &n){
 	pa=La->next;
 	pb=Lb->next;
 	pre=La;
 	while(pa&&pb){
 		if(pa->data<pb->data){
 			n++;
 			pre=pa;
 			pa=pa->next;
 		}
 		else if(pa->data>pb->data){
 			pb=pb->next;
 		}
 		else{
 			pre->next=pa->next;
 			u=pa;pa=pa->next;delete u;
 		}
 	}
 	while(pa){
 		n++;
 		pa=pa->next;
 	}
}
```

5.将一个带头节点的非零单链表A分解为两个具有相同结构的链表B和C，其中B表示的节点为A表中值小于零的结点，而C表为大于零的节点

```c++
void Decompose(LinkList &La,LinkList &Lb,Linklist &Lc){
	pa=La->next;
	Lb=La;Lb->next=NULL;
	Lc = new LNode;Lc->next=NULL;
	while(pa!=NULL){
		r=pa->next;//因为前插法会改变pa->next，所以事先存一下
		if(pa->data<0){
			pa->next=Lb->next;
			Lb->next=pa;
		}
		else{
			pa->next=Lc->next;
			Lc->next=pa;
		}
		pa=r;
	}
}
```

6.通过一趟遍历确定长度为n的单链表中值最大的级诶按，返回该节点的数据域

```c++
ElemType Max(Linklist L){
    if(L->next==NULL)return NULL;
    pmax=L->next;
   	p=L->next->next;
    while(p!=NULL){
        if(p->data>pmax->data)pmax=p;
        p=p->next;
    }
    return pmax->data;
}
```

7.将链表中所有结点的链接访问方向原地旋转，要求仅利用原表的存储空间

```c++
void Inverse(Linklist &L){
	p=L->next;
	L->next=NULL;
	while(p!=NULL){
		q=p->next;
		p->next=L->next;
		L->next=p;
		p=q;
	}
}
```

8.删除递增有序链表中值大于mink且小于maxk的所有元素

```c++
void DeleteMinMax(Linklist &L,int mink,int maxk){
	p=L->next;pre=L;
	while(p&&p->data<=mink){
		pre=p;
		p=p->next;
	}
	while(p&&p->data<maxk)p=p->next;
    q=pre->next;
    pre->next=p;
    while(q!=p){
    	s=q->next;
    	delete q;
    	q=s;
    }
}
```

自己的

```c++
void DeleteMinMax(Linklist &L,int mink,int maxk){
	p=L->next;
    pre=L;
    while(p){
        if(p->data>mink&&p->data<maxk){
          pre->next=p->next;
          u=p;p=p->next;delete u;
        }
        else p=p->next;
    }
}
```

9.已知p指向双向循环链表的一个结点，其结点结构为data,prior,next三个区域，写出算法Exchange(p),交换p所指向的结点及其前驱节点的顺序

```c++
void Exchange(DuLinklist p){
    q=p->prior;
    
    q->prior->next=p;
    p->prior=q->prior;
    
    q->next=p->next;
    q->prior=p;
    
    p->next->prior=q;
    p->next=q;
    
}
```

10.已知长度为n的线性表A采用顺序存储结构，写一个时间复杂度为O(N)空间复杂度为O（1）的算法，该算法可删除线性表内所有值为item的元素

```c++
void DeleteItem(SqList &La,ElemType item){
	k=0;
	for(int i=0;i<La.length;i++){
		if(La.Elem[i]!=item){
			La.Elem[k]=item;
			k++;
		}
	}
	La.length=k;
}
```



## 栈和队列

1.将编号为0和1的两个栈存放于一个数组空间V[m]中，栈底分别处于数组的两端。当第0号栈的栈顶指针top[0]=-1时栈空，当第1号栈的栈顶指针top[1]=m时栈空，两个栈从两边向中间生长。编写双栈初始化，判断栈空，栈满，进栈和出栈等算法的函数

```c++
int isEmpty(DblStack S,int i){
	return S.top[i]==S.bot[i];   
}

int isFull(Dblstack S){
    return S.top[0]+1==S.top[1];
}

Status Init(DblStack &S,int m){
    S.V = new SElemType[m];
    S.top[0]=S.bot[0]=-1;
    S.top[1]=S.bot[1]=m;
    return OK;
}

Status Push(DblStack &S,SElemType x,int i){
    if(S.top[0]+1==S.top[1])return ERROR;
    if(i==0)S.V[++S.top[0]]=x;
    else S.V[--S.top[1]]=x;
    return OK;
}

void Pop(DblStack &S,SElemType &x,int i){
    if(S.top[i]==S.bot[i])return ERROR;
    if(i==0)x=S.V[S.top[0]--];
    else x=S.V[S.top[1]++];
    return OK;
}
```

2.用栈进行字符串回文判断

```c++
int IsPalindrome(char *t){
	InitStack(S);
	int len=strlen(t);
	int i=0;
	for(i=0;i<len/2;i++)Push(S,t[i]);
	if(len%2==1)i++;
	while(!EmptyStack(S)){
		x=Pop(S);
		if(x!=t[i])return 0;
		else i++;
	}
	return 1;
}
```

3.输入整数序列，用栈存储输入的整数，如果整数不等于-1,就进栈，否则输出栈顶整数并出栈。算法应对异常情况给出信息

```c++
void InOutS(int S[]){
	top=0;
    for(int i=1;i<=n;i++){
        cin>>x;
        if(x!=-1){
            if(top==MAXSIZE-1){
                puts("栈满");
                exit(0);
            }
            else S[++top]=x;
        }
        else{
            if(top==0){
                puts("栈空");
                exit(0);
            }
           	else cout<<"栈顶元素"<<S[top--]<<endl; 
        }
    }
}
```

4.从键盘上输入一个后缀表达式，是编写算法计算表达式的之。规定逆波兰式长度不超过1行，以$作为输入结束，操作数之间空格分开，操作符只有+-*/

```c++
void Postfix(){
	InitStack(OPND);
	num=0.0;
	ch=getchar();
	while(ch!='$'){
		int i=0;
		while((ch>='0'&&ch<='9')||ch=='.'){
			data[i++]=ch;
			ch=getchar();
		}
		num=atof(data);
		Push(OPND,num);
		switch(ch){
			case:' ':break;
			case:'+':Pop(OPND,b);Pop(OPND,a);Push(OPND,a+b);
			case:'-':Pop(OPND,b);Pop(OPND,a);Push(OPND,a-b);
			case:'*':Pop(OPND,b);Pop(OPND,a);Push(OPND,a*b);
			case:'/':Pop(OPND,b);Pop(OPND,a);Push(OPND,a/b);
		}
		ch=getchar();
	}
	return GetTop(OPND);
}
```

5.假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，称可以操作的序列为合法序列，否则称为非法序列

```c++
bool Judge(char A[]){
	int check=0;
	for(int i=0;A[i];i++){
		if(A[i]=='I')check++;
        else check--;
        if(check<0)return 0;
	}
	if(check!=0)return 0;
	return 1;
}
```

6.假设以带头节点的循环链表表示队列，并且只设一个指针指向队尾元素节点（注意，不设头指针），试编写相应的置空队列，判断队列是否为空，入对和出队等算法

```c++
typedef struct QNode{
	QElemType data;
	struct QNode *next;
}QNode,*QueuePtr;
typedef struct{
	QueuePtr rear;
}LinkQueue;

void InitQueue(LinkQueue &Q){
    Q->rear=Q->rear->next;
    while(Q->rear!=Q->rear->next){
        s=Q->rear->next;
        Q->rear->next=s->next;
        delete s;
    }
}
int EmptyQueue(LinkQueue &Q){
    return Q->rear->next->next==Q->rear->next;
}
Status EnQueue(LinkQueue &Q,QElemType e){
    p = new QueueNode;
    p->data = e;
    p->next = Q->rear->next;
    Q->rear->next=p;
    Q->rear=p;
    return OK;
}
Status DelQueue(LinkQueue &Q,QElemType e){
    if(Q->rear->next->next==Q->rear->next)return ERROR;
    p = Q->rear->next->next;
    e = p->data;
    Q->rear->next=p->next;
    delete p;
}
```

7.假设以数组Q[m]存放循环队列中的元素，同时设置一个标志tag,以tag\==0和tag\==1来区别front==rear时是空还是满，编写插入和删除算法

```c++
typedef struct {
    QElemType *base;
    int front,rear,tag;
}SeQueue;

Status InitQueue(SeQueue &Q){
    Q.base = new QElemType[M];
    Q.front=Q.rear=Q.tag=0;
    return OK;
}

Status EnQueue(SeQueue &Q,QElemType e){
    if(Q->tag==1&&(Q.front==Q.rear))return ERROR;
    Q.base[Q.rear]=e;
    Q.rear=(Q.rear+1)%M;
    if(Q.tag==0)Q.tag=1;
    return OK;
}

Status DelQueue(SeQueue &Q,QElemType &e){
    if(Q->tag==0&&(Q.front==Q.rear))return ERROR;
   	e=Q.base[Q.front];
    Q.front=(Q.front+1)%M;
    if(Q->tag==1)Q->tag=0;
    return OK;
}
```

8.如果允许在循环队列的两端都可以进行插入和删除的操作，写出循环队列的类型定义，从队尾删除和从队头插入的算法

```c++
typedef struct{
    QElemType *base;
    int front,rear;//front为队头元素的前一个元素，rear为队尾元素的后一个元素
}SeQueue;

Status EnQueue(SeQueue &Q,QElemType e){
    if(Q.rear==(Q.front-1+M)%M)return ERROR;
    Q[Q.front]=e;
    Q.front=(Q.front-1+M)%M;
    return OK;
}

Status DelQueue(SeQueue &Q,QElemType &e){
    if(Q.rear==Q.front)return ERROR;
    e=Q.[Q.rear];
    Q.rear=(Q.rear-1+M)%M;
    return OK;
}
```



9.写出Ack(m,n)函数的递归算法和非递归算法

```c++
#include <iostream>
#include <tuple>
using namespace std;
using LL = long long;
// n = 0 --> n + 1
//
// Ack(n - 1 , Ack(n , m - 1))
struct Node {
  LL m, n;
  LL stat = -1;
  Node *Next;
};
struct Stack {
  Node *Top = NULL;
  int sz = 0;
  bool Is_Empty() { return sz == 0; }
  void pop() {
    Node *T = Top;
    Top = Top->Next;
    delete T;
    sz--;
  }
  void push(int m, int n, int stat) {
    Node *T = new Node;
    T->n = n, T->m = m, T->stat = stat;
    T->Next = Top;
    Top = T;
    sz++;
  }
  tuple<LL, LL, LL> top() { return {Top->m, Top->n, Top->stat}; }
  void print() {
    Node *T = Top;
    while (T != NULL) {
      int x = T->m;
      int y = T->n;
      int z = T->stat;
      cerr << x << ' ' << y << ' ' << z << '\n';
      T = T->Next;
    }
    cerr << '\n';
  }
};
LL ACK(int m, int n) {//递归
  if (m == 0) return n + 1;
  if (n == 0) return ACK(m - 1, 1);
  return ACK(m - 1, ACK(m, n - 1));
}
LL Ack(int m, int n) {//非递归
  Stack S;
  S.push(m, n, -1);
  LL res = 0;
  while (!S.Is_Empty()) {
#ifdef DEBUG
    S.print();
#endif
    auto [m, n, stat] = S.top();
    S.pop();
    if (m == 0) {
      res = n + 1;
      continue;
    }
    if (n == 0) {
      S.push(m - 1, 1, -1);
      continue;
    }
    if (stat == -1) {
      stat = res;
      S.push(m, n, stat);
      S.push(m, n - 1, -1);
      continue;
    }
    S.push(m - 1, res, -1);
  }
  return res;
}
int main() {
  cout << ACK(3, 4) << '\n';
  cout << Ack(3, 4) << '\n';
  return 0;
}

```

10.已知f为单链表的表头指针，链表中存储的都是整型数据，试写出实现下列运算的递归算法

求链表中的最大整数

求链表的节点个数

求所有整数的平均值

```c++
int GetMax(LinkList p){
	if(!p->next)return p->data;
    else{
        int max=GetMax(p->next);
        return p->data>max?p->data:max;
    }
}

int GetLength(Linklist p){
    if(!p->next)return 1;
    else{
		return GetLength(p->next)+1;
    }
}

int GetAve(Linklist p,int n){
    if(!p->next)return p->data;
    else{
		double ave=GetAve(p->next,n-1);
        return (ave*(n-1)+p->data)/n;
    }
}
```



## 串、数组、广义表

## 树和二叉树

## 图

## 查找

## 排序