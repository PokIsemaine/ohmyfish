## 第2章 线性表

线性结构特点：

存在一个被称作第一个的数据元素

存在一个被称作最后一个的数据元素

除第一个外，集合中每个数据元素均只有一个前驱

除最后一个外，集合中的每个数据元素均只有一个后继



### 2.3~2.4 线性表的顺序存储结构

顺序表：将线性表的元素一个接一个地存储在相邻的一片区域中

**顺序表特点：**

以元素在计算机内存中物理位置相邻来表示数据元素之间逻辑关系

只要确定首地址，线性表中任意数据元素都可以随机存取

存储密度=1



**顺序表基本操作：**

初始化：长度为0

取值：O(1)

查找：ASL（平均查找长度，就是平均比较次数）=(n+1)/2，O(N)

插入：在第i个位置插入一个元素需要移动n-i+1个元素，$E_{ins}=n/2$，O(N)

删除：删除第i个元素，需要移动n-i个元素,$E_{del}=(n-1)/2$，O(N)



关于$E_{ins},E_{del}$要知道期望不是相等是的概率怎么算，最好会求平方和立方和

$\sum_{i=1}^ni^2=\frac{(k+1)(k+2)(2k+3)}{6}$

$\sum_{i=1}^ni^3=\frac {n^4+2n^3+n^2}{4}$



**顺序存储的优点：**

逻辑相邻物理相邻

可以随机存取任一元素

存储空间使用紧凑



**顺序存储的缺点：**

插入删除操作需要移动大量元素

预先分配空间需按最大空间分配，利用不充分

表容量难以扩充



### 2.5 线性表的链式表示和实现

线性表的链式表示：

用指针表示一组数据元素的逻辑关系

元素的存储可以是连续的也可以不是连续的

结点至少包括数据元素和指针两个部分



**那个表示方法也要看一下怎么表示**

链表增加头节点的作用：便于首元节点的处理，便于空表和非空表统一处理（如果为空表，头节点指针域为空）

#### 单链表

单链表基本操作：

初始化：创建新节点作为头节点，头节点指针域置空

取值：ASL=(n-1)/2，O(N)

查找：O(N)

插入：不需要移动但是要定位所以还是O（N）

删除：不需要移动但是要定位所以还是O（N）

创建单链表：前插法后插法都O（N）

单链表查找直接后继结点的执行时间为O（1），而查找直接前驱的执行时间为O（N）

单链表是**非随机存储的存储结构**，取得第i个数据元素必须从头指针出发顺链寻找，**也称为顺序存取的存取结构**

存储密度小于1

#### 循环链表

循环链表：最后一个节点的指针域指向头节点，形成一个环

循环单链表和单链表操作基本一致，差别在于判别当前指针是否指向表尾节点的条件不同。

单链表：p！=NULL或p->next!=NULL

循环单链表p！=L或p->next!=L

若在循环链表中设立为指针而不设头指针，两个线性表合成一个表时，只需将第一个表的尾指针指向第二个链表的第一个节点，第二个表的尾指针指向第一个表的头节点，然后释放第二个表的头节点，时间复杂度为O（1）

#### 双向链表

双向链表：优化单链表查找直接前驱时间为O（N），双向链表有两个指针域，一个指向直接后继，一个指向直接前驱

双向链表在插入和删除上和单链表不同，插入节点要修改四个指针，删除节点要修改两个节点，两者的时间复杂度均为O（N）

插入和删除算法背下来

### 顺序表和链表比较

$存储密度=数据元素本身占用的存储量/结点结构占用的存储量$

熟记书本P50～51两个表



### 算法设计

1.两个递增有序表合并程一个递增有序表,不能重复

```c++
void MergeList(LinkList &La,Linklist &La,LinkList &Lc){
    pa=La->next;
    pb=Lb->nextl
    Lc=pc=La;
    while(pa&&pb){
        if(pa->data<pb->data){
            pc->next=pa;
            pc=pa;
            pa=pa->next;
        }
        else if(pa->data>pb->data){
            pc->next=pb;
            pc=pb;
            pb=pb->next;
        }
        else{
            pc->next=pa;
            pc=pa;
            pa=pa->next;
            q=pb->next;
            delete pb;
            pb=q;
        }
    }
    pc->next=pa?pa:pb;
    delete Lb;
}
```

2.两个非递减有序链表合并为一个非递增有序链表

```c++
void MergeList(LinkList &La,Linklist &La,LinkList &Lc){
    pa=La->next;
    pb=Lb->nextl
    Lc=pc=La;
    Lc->next=NULL;
    while(pa||pb){
    	if(!pa){
    		q=pb;
    		pb=pb->next;
    	}
    	else if(!pb){
    		q=pa;
    		pa=pa->next;
    	}
    	else if(pa->data<=pb->data){
    		q=pa;
    		pa=pa->next;
    	}
    	else{
    		q=pb;
    		pb=pb->next;
    	}
    	q->next=Lc->next;Lc->next=q;
    }
    delete Lb;
}
```

3.已知两个链表A和B分别表示两个集合，其元素递增排列，求交集放在A链表中

```c++
void Intersection(LinkList &La,Linklist &Lb,Linklist &Lc){
	pa=La->next;
    pb=Lb->nextl
    Lc=pc=La;
    while(pa&&pb){
    	if(pa->data==pb->data){
    		pc->next=pa;
 			pc=pa;
 			pa=pa->next;
 			u=pb;pb=pb->next;delete u;
    	}
    	else if(pa->data<pb->data){
    		u=pa;pa=pa->next;delete u;
    	}
    	else{
    		u=pb;pb=pb->next;delete u;
    	}
    }
    while(pa){
    	u=pa;pa=pa->next;delete u;
    }
    while(pb){
    	u=pb;pb=pb->next;delete u;
    }
    pc->next=NULL;
    delete Lb;
}
```

4.已知两个链表A,B元素递增排列，求A-B差集，并返回集合元素个数

```c++
void Difference(Linklist &La,Linklist &Lb,int &n){
 	pa=La->next;
 	pb=Lb->next;
 	pre=La;
 	while(pa&&pb){
 		if(pa->data<pb->data){
 			n++;
 			pre=pa;
 			pa=pa->next;
 		}
 		else if(pa->data>pb->data){
 			pb=pb->next;
 		}
 		else{
 			pre->next=pa->next;
 			u=pa;pa=pa->next;delete u;
 		}
 	}
 	while(pa){
 		n++;
 		pa=pa->next;
 	}
}
```

5.将一个带头节点的非零单链表A分解为两个具有相同结构的链表B和C，其中B表示的节点为A表中值小于零的结点，而C表为大于零的节点

```c++
void Decompose(LinkList &La,LinkList &Lb,Linklist &Lc){
	pa=La->next;
	Lb=La;Lb->next=NULL;
	Lc = new LNode;Lc->next=NULL;
	while(pa!=NULL){
		r=pa->next;//因为前插法会改变pa->next，所以事先存一下
		if(pa->data<0){
			pa->next=Lb->next;
			Lb->next=pa;
		}
		else{
			pa->next=Lc->next;
			Lc->next=pa;
		}
		pa=r;
	}
}
```

6.通过一趟遍历确定长度为n的单链表中值最大的级诶按，返回该节点的数据域

```c++
ElemType Max(Linklist L){
    if(L->next==NULL)return NULL;
    pmax=L->next;
   	p=L->next->next;
    while(p!=NULL){
        if(p->data>pmax->data)pmax=p;
        p=p->next;
    }
    return pmax->data;
}
```

7.将链表中所有结点的链接访问方向原地旋转，要求仅利用原表的存储空间

```c++
void Inverse(Linklist &L){
	p=L->next;
	L->next=NULL;
	while(p!=NULL){
		q=p->next;
		p->next=L->next;
		L->next=p;
		p=q;
	}
}
```

8.删除递增有序链表中值大于mink且小于maxk的所有元素

```c++
void DeleteMinMax(Linklist &L,int mink,int maxk){
	p=L->next;pre=L;
	while(p&&p->data<=mink){
		pre=p;
		p=p->next;
	}
	while(p&&p->data<maxk)p=p->next;
    q=pre->next;
    pre->next=p;
    while(q!=p){
    	s=q->next;
    	delete q;
    	q=s;
    }
}
```

自己的

```c++
void DeleteMinMax(Linklist &L,int mink,int maxk){
	p=L->next;
    pre=L;
    while(p){
        if(p->data>mink&&p->data<maxk){
          pre->next=p->next;
          u=p;p=p->next;delete u;
        }
        else p=p->next;
    }
}
```

9.已知p指向双向循环链表的一个结点，其结点结构为data,prior,next三个区域，写出算法Exchange(p),交换p所指向的结点及其前驱节点的顺序

```c++
void Exchange(DuLinklist p){
    q=p->prior;
    
    q->prior->next=p;
    p->prior=q->prior;
    
    q->next=p->next;
    q->prior=p;
    
    p->next->prior=q;
    p->next=q;
    
}
```

10.已知长度为n的线性表A采用顺序存储结构，写一个时间复杂度为O(N)空间复杂度为O（1）的算法，该算法可删除线性表内所有值为item的元素

```c++
void DeleteItem(SqList &La,ElemType item){
	k=0;
	for(int i=0;i<La.length;i++){
		if(La.Elem[i]!=item){
			La.Elem[k]=item;
			k++;
		}
	}
	La.length=k;
}
```

