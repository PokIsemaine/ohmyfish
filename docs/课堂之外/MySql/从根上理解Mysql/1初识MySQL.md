# 第1章 装作自己是一个小白：初识MySQL

## 1.1 MySQL 的客户端/服务器架构

`MySQL` 的服务器程序直接与要存储的数据打交道，多个客户端程序可以连接到这个服务器程序，向服务器发送增删查改的请求 ， 然后服务器程序根据这些请求，对存储的数据进行相应处理.

1. 启动 `MySQL` 服务器程序.

2. 启动 `MySQL` 客户端程序，并连接到服务器程序.
3. 在客户端程序中输入命令语句 ， 并将其作为请求发送给服务器程序.服务器程序在收
	到这些请求后，根据请求 的内容来操作具体的数据，并将结果返回给客户端.

## 1.2 MySQL 的安装

记住 `MySQL` 的安装目录

### 1.2.1 bin 目录下的可执行文件

忘记放哪里了但我现在可以直接 `MySQL`

使用`whcih` 列出命令所在路径

```shell
which mysql

/usr/bin/mysql
```

### 将 bin目录的绝对路径加入到环境变量PATH中

将 `bin` 目 录的绝对路径 加入到环境变量 `PATH` 中。
大家应该发现，若每次执行一个文件都需要输入一长串路径名 ，这未免太麻烦了.针对这种情况 ， 可以把 bin 目录所对应的绝对路径添加到环境变盘 `PATH` 中，环境变量 `PATH `是一系列路径的集合，各个路径之间使用冒号`(:)`隔离开。

```shell
# 查看环境变量
export
# 输出PATH
echo $PATH
# 加入环境变量(临时)
export  PATH=新增路径:$PATH

# 永久，文件最后添加
export PATH=新增路径:$PATH
# 永久全局
vim /etc/profile
# 永久当前用户
vim ~/.bashrc

```

这样以后就可以直接执行`mysql`不用一大堆路径了

## 1.3 启动 MySQL 服务器程序

* `mysqld`

	`mysqld` 可 执行文件 就表示 `MySQL` 服务器程序 ， 运行这个可执行文件就可以直接启动一个`MySQL `服务器进程

* `mysqld_safe`

	会间接调用`mysqld`并持续监控 服 务器 的运行状态.当服务器进程出现错误 时 ，它还可以帮助重启 服务器程序.另外，使用 `mysqld_safe` 启动 `MySQL`服务器程序时 ，它会 将服 务器 程 的出错信息 和 其他诊断信息输出到错误日志

* `mysql.server` 

	启动脚本，间接调用 `mysql_safe`，添加`start`参数即可

```shell
mysql.server start
```

* `mysqld_multi`

允许或停止多个服务器进程并报告状态

## 1.4 启动 MySQL 客户端程序

启动

```shell
mysql -h主机名 -u用户名 -p密码
```

退出

```shell
quit
exit
\q
```

### 1.4.1 连接注意事项

* 最好不要在一行命令中输入密码

```shell
mysql -h 主机名 -u 用户名 -p
# 回车后才会提示输入密码，不过这次的密码不会被显示出来
```

* 如果非要在一行命令中显式地输入密码，那么 `-p`和密码值之间不能有空白字符(其他参数名和参数值之间可以有空白字符)

```shell
mysql -h 主机名 -u 用户名 -p12345
```

* `mysql`各个参数的顺序没有硬性规定
* 如果服务器和客户端安装在同一台机器上，`-h`参数可以忽略
* 如果使用的是类`UNIX`系统，省略`-u`参数后，会把登陆操作系统的用户名当作`MySQL`的用户名去处理



## 1.5 客户端与服务器连接的过程

### 1.5.1 TCP/IP

`MySQL` 采用 `TCP` 作为服务器和客户端之间的网络通信协议

`MySQL`服务器在启动时默认申请 3306 端口（即默认监听 3306端口）

如果`3306`端口已经被别的进程占用，或者想自定义可以在启动服务器程序的命令行中添加`-P`参数来明确指定端口号（区分大小写）

```shell
mysqld -P3307
```

如果客户端进程想要用`TCP/IP`与服务器进程继续你同学，那么`-h`参数后就要跟服务器进程的主机名，`-P`可以指定端口

```shell
#127.0.0.1表示本机地址
mysql -h127.0.0.1 -uroot -P3307 -p
```

### 1.5.2 命名管道和共享内存

如果是`Windows`用户，可以用命名管道和共享内存进行通信

命名管道

* 服务器命令加上`--enable-named-pipe`
* 客户端命令加上`--pipe`或`--protocol=pipe`

共享内存

* 服务器命令加上`--shared-memory`
	* 客户端命令加上`--protocol=memory`

### 1.5.3 UNIX 域套接字

客户端参数`--protocol=socket`

`MySQL`服务器程序默认监听`UNIX`域套接字文件名称为`/tmp/mysql.sock`，客户端也默认链接这个

如果要该可以在启动服务器程序时指定`socket`参数

```shell
# 服务端
mysqld --socket=/tmp/a.txt
# 客户端
mysql -hlocalhost -uroot --socket=/tmp/a.txt -p
```



## 1.6 服务器处理客户端请求

![image-20220329200252510](https://s2.loli.net/2022/03/29/a8lKOpZ6ey2LHVk.png)

### 1.6.1 连接管理

**创建进程 **

每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程专门处理与这个客户端的交互 

**断开连接但缓存线程**

当该客户端退出时会与服务器断开连接 ， 服务器并不会立即把与该客户端交互的线程销毁 ， 而是把它缓存起来 ， 在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端 .这 样就不用频繁地创建和销毁线程，从而节省了开销.从这一点大家也能看出， MySQL 服务器会为每一个连接进来的客户端分配一个线程，但是线程分配得太多会严重影响系统性能 ， 所以我们也需要限制可以同时连接到服务器的客户端数量，至于怎么限制我们后边再说 

**信息认证**

在客户端程序发起连接时 ， 需要携带主机信息、用户名、密码等信息，服务器程序会对客户端程序提供的这些信息进行认证.如果认证失败 ， 服务器程序会拒绝连接.

**连接加密**

另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以通过采用传输层安全性 (Transpo rtLayer Security, TLS) 协议对连接进行加密，从而保证数据传输的安全性。

**等待请求**

当连接建立后，与该客户端关联的服务器线程会 一直等待客户端发送过来的请求（文本信息）

### 1.6.2 解析与优化

MySQL 服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理

1. 查询缓存
	* MySQL 服务器程序处理查询请求时会把刚刚处理过的查询请求和结果缓存起来
	* 如果两个查询字符上完全一样也不一定缓存命中，以某些系统函数为例，同 一 个函数的两次调用可能会产生不一样的结果 . 比如函数 NOW. 每次调用时都会产生最新的当前时间.如果在两个查询请求中调用了这个函数，即使查询请求的文本信息都一样，那么不同时间的两次查询也应该得到不同的结果.如果在第 一 次查询时就缓存了结果，在第二次查询时直接使用第一次查询的结果就是错误的 !
	* 缓存会过期需要更新，缓存系统会检测每张表。虽然查询可以提高系统性能，但维护缓存也需要开销。MySQL 5.7.20 开始不推荐使用查询缓存，在 MySQL 8.0 中直接将其删除

2. 语法解析

	如果查询缓存没有命中，接下来就需要进入正式的查询阶段了.因为客户端程序发送过来的请求只是 一 段文本 ， 所以 MySQL 服务器程序首先妥对这段文本进行分析 ， 判断请求的语法是否正确，然后从 文 本中将要查询的表、各种查询条件都提取出来放到 MySQL 服务器内部使用的一些数据结构上

3. 查询优化

	因为我们写的 MySQL 语句执行起来效率可能并不是很高， MySQL 的优化程序会对我们的话句做一些优化，如外连接转换为内连接、表达式简化 、子查询转为连接等一堆东西

### 1.6.3 存储引擎

MySQL 服务器把数据的存储和提取操作都封装到了一个名为存储引擎的模块中.我们知道，表是由一行 一 行
的记录组成的，但这只是一个逻辑上的概念.在物理上如何表示记录，怎么从表中读取数据，以及怎么把数据写入具体的物理存储器上，都是存储引擎负责的事情。



## 1.7 常用存储引擎

![image-20220329203933535](https://s2.loli.net/2022/03/29/TxvrRDH54kz8iuK.png)

最常用的`InnoDB`（5.5.5版本开始作为默认引擎）,`MyISAM`和`MEMORY`

## 1.8 关于存储引擎的一些操作

### 1.8.1 查看当前服务器程序支持的存储引擎

```mysql
SHOW ENGINES;
```

### 1.8.2 设置表的存储引擎

```hmysql
# 创建表时指定
CREATE TABLE 表名(
	建表语句;
) ENGINES = 存储引擎名称;

# 修改表的存储引擎
ALTER TABLE 表名 ENGINES = 存储引擎名;
```