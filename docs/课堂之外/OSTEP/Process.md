# 抽象：进程

如何提供有许多CPU的假象：虚拟化CPU

时分共享CPU技术：通过让一个进程只运行一个时间片，然后切换到其他进程，提供存在多个CPU的假象

潜在开销：性能损失

要想把CPU的虚拟化实现的好需要一些低级机制以及一些高级智能。

需要提供的机制（低级方法或协议），例如上下文切换机制，让操作系统能够停止运行一个程序

只能以策略的形式存在（算法），例如调度策略

## 4.1 抽象：进程

操作系统为正在运行的程序提供的抽象，就是所谓的进程。

进程的构成-->机器状态：内存（地址空间）、寄存器（PC、IP、栈指针、帧指针）、I/O文件列表

分离策略和机制：高级策略（which）与低级机制（how）分离，模块化

## 4.2 进程 API

创建、销毁、等待、其他控制、状态

## 4.3 进程创建：更多细节

如何将程序转换为进程？（如何启动运行一个程序？进程创建实际如何进行）

**1代码和静态数据加载到内存中，加载到进程的地址空间中**

早期OS加载过程尽可能早，在运行程序前全部完成

现代OS惰性加载，只有程序执行期间需要加载的代码片段或数据片段才会被加载。（分页、交换机制）

**2为程序运行时栈分配一些内存，可能还会分配一些堆内存**



**3操作系统还会执行一些其他初始化任务，特别是输入/输出（I/O）相关的任务**

UNIX默认的3个文件描述符：标准输入、输出和错误

**4舞台搭建完毕，启动程序**

启动程序，在入口处执行（main），通过跳转到`main()`，OS将CPU的控制权转移到新创建的进程中，程序开始运行



提出问题：

如何用分页、交换机制实现现代OS惰性加载？

启动程序如何跳转到`main()`?



### 4.4 进程状态

进程在给定时间可能处于不同状态

运行状态：在运行状态下，进程正在处理器上运行，执行指令

就绪状态：进程已经准备好了，但由于某种原因操作系统选择不在此时运行

阻塞状态：进行执行了某种操作，直到发生其他事件时才会准备运行（磁盘I/O）

还有些进程可能处于

初始状态：进程在创建时处于的状态

最终状态：程序已经退出但尚未清理（UNIX中称为僵尸状态），最终状态可以用来检查进程返回的代码，看看进程是否执行成功

### 4.5 数据结构

操作系统是个程序，有一些关键数据结构来跟踪信息，例如进程列表，便于跟踪进程信息。

人们会将存储关于进程的信息的个体结构成为进程块（PCB）

