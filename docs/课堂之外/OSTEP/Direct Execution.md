# 机制：受限直接执行

我们可以通过时分共享CPU实现虚拟化

> 关键问题：如何高效、可控的虚拟化CPU
>
> 操作系统必须以高性能的方式虚拟化CPU，同时保持对系统的控制。为此，需要硬件和操作系统支持。操作系统通常会明智地利用硬件支持，以便高效地实现其工作

两个要点：性能，控制权

## 6.1 基本技巧：受限直接执行

为了让程序尽可能快地运行，使用受限直接执行技术。

直接执行部分：只需直接在CPU上运行程序即可

| 步骤            | 操作系统                               | 程序               |
| --------------- | -------------------------------------- | ------------------ |
| 1               | 在进程列表上创建条目                   |                    |
| 2               | 为程序分配内存                         |                    |
| 3               | 将程序加载到内存中                     |                    |
| 4               | 根据 argc/argv 设置程序栈              |                    |
| 5               | 清除寄存器                             |                    |
| 6               | 执行 call main() 方法                  |                    |
| 7控制权OS->程序 |                                        | 执行 main()        |
| 8控制权程序->OS |                                        | 从main()执行return |
| 9               | 释放进程的内存，将进程从进程列表中清楚 |                    |

这样有个两个问题

问题1：如果我们只运行一个程序，操作系统怎么确保程序不做任何我们不希望它做的事，同时仍然高效地运行它？

问题2：当我们运行一个进程时，操作系统如何让它停下来并切换到另一个进程

## 6.2 问题1：受限制的操作

> 关键问题
>
> 一个进程必须能够执行I/O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这点

采用受保护的控制权转移，硬件通过提供不同的执行模式来协助操作系统。

硬件提供了

* 用户模式，应用程序不能完全访问硬件资源
* 内核模式，操作操作系统可以访问机器全部资源
* 陷入（trap）内核
* 从陷阱返回用户模式，硬件必须确保存储足够的调用者寄存器，以确保返回的时候正确
* 一些指令，让操作系统告诉硬件陷阱表在内存中的位置



为什么系统调用看起来像过程调用?

是一个过程调用，但隐藏在过程调用内部的是著名的陷阱指令。

陷阱如何知道









