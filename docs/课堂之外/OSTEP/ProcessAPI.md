# 插叙：进程 API

关键问题：如何创建并控制进程

## 5.1 fork()系统调用

* 创建心进程的方法几乎与调用进程完全一样
* 子进程并不是完全拷贝副进程，有自己的地址空间、寄存器、程序计数器
* 父进程fork返回值是新创建子进程的PID,子进程获得的返回值是0
* 子进程被创建后，子进程或父进程此时都有可能运行，输出是不确定的。CPU的调度程序决定某个时刻那个进程被运行



## 5.1 wait() 系统调用

* 父进程调用`wait()`延迟自己执行，知道子进程执行完毕。当子进程结束时，`wait()`才返回父进程



## 5.3 最后是 exec()系统调用

* 创建API的一个重要部分，`fork()`只是在你想运行相同程序的拷贝时有用，但我们常常想运行不同的程序，`exec()`可以让子进程执行与父进程不同的程序
* 给定可执行程序的名称以及需要的参数后，`exec()`会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段(静态数据)，堆、栈以及其他内存空间也会被重新初始化。然后操作系统执行该程序，将参数通过`argv`传给该进程。因此，它并没有创建新进程，而是直接将当前程序替换为不同的程序
* 因为直接被替换了，子程序执行`exec()`后就像原来程序从未运行过一样，对`exec()`的成功调用永远不会返回



## 5.4 为什么这样设计 API

为什么要分离`fork()`和`exec()`?

这给了`shell`在`fork()`之后`exec()`之前运行代码的机会，这部分代码可以在运行新程序之前改变环境

> 重要的是做对事（LAMPSON 定律）:做对事。抽象和简化都不能替代做对事

分离后可以`shell`可以方便地实现一些功能

```shell
wc p3.c > newfile.txt
```

`wc`的输出结果被重定向到`newfile.txt`中

`shell`实现结果重定向很简单，子进程创建后，`shell`在调用`exec()`之前关闭了标准输出，打开了`newfile.txt`，这样就能把即将运行程序`wc`的结果从打印到屏幕上改为发送到文件里。（UNIX从0开始寻找文件描述符，`STDOUT_FILENO`作为第一个可用的文件描述符，在`open`被调用的时候得到赋值，然后子进程想标准输入文件符的写入都会被透明地转向被打开的文件而不是屏幕）

[关于重定向](https://www.cnblogs.com/weidagang2046/p/io-redirection.html)

前一个进程的输出作为后一个进程的输入的操作大多可以用这种方式来实现



> RTFM:Read The Friendly Man

## 其他 API

`kill()`向进程发送信号，包括要求进程睡眠、终止或其他指令

`ps`查看当前正在运行的进程

`top`用于展示当前系统进程消耗`CPU`或其他资源的情况（然后`top`自己往往是最占资源的哈哈`）

