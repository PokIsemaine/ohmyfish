# Lab3 实现 TCP 发送方

## 概述

在 Lab 0 中，您实现了流控制字节流 (ByteStream) 的抽象。 在实验 1 和 2 中，您实现了将不可靠数据报中携带的段转换为传入字节流的工具：StreamReassembler 和 TCPReceiver。 

现在，在实验 3 中，您将实现连接的另一端。 TCPSender 是一种工具，可将传出字节流转换为将成为不可靠数据报有效负载的段。 最后，在实验 4 中，您将结合前面的工作和实验来创建一个有效的 TCP 实现：一个包含 TCPSender 和 TCPReceiver 的 TCPConnection。 您将使用它与 Internet 上的真实服务器通信。

![image-20220726103422931](https://s2.loli.net/2022/07/26/e5I4HkRsF7calqN.png)

## 设计

TCP 是一种通过不可靠的数据报可靠地传送一对流控制字节流（每个方向一个）的协议。两方参与 TCP 连接，每一方同时充当（其自己的传出字节流的）“发送者”和（传入字节流的）“接收者”。两方被称为连接的“端点”或“对等点”。

本周，您将实现 TCP 的“发送方”部分，**负责读取 ByteStream（由某些发送方应用程序创建和写入），并将流转换为一系列传出 TCP 段**。在远程端，TCP 接收器 1 将这些段（那些到达的——它们可能不会全部到达）转换回原始字节流，并将确认和窗口广告发送回发送者。 

TCP 发送方和接收方各自负责 TCP 段的一部分。 TCP 发送方写入 TCPSegment 中与实验 2 中的 TCPReceiver 相关的所有字段：即序列号、SYN 标志、有效负载和 FIN 标志。但是，**TCP 发送方只读取接收方写入的段中的字段：确认和窗口大小**。这是 TCP 段的结构，仅突出显示发送方将读取的字段：

![image.png](https://s2.loli.net/2022/09/07/BDPEA1Upct9KMoz.png)

您的 TCPSender 将负责： 

*  跟踪接收者的窗口（处理传入的确认 `ackno` 和窗口大小 `window size`） 
*  尽可能填充窗口，通过从 ByteStream 读取，创建新的 TCP 段（包括 SYN 和 FIN 标志，如果需要）， 并发送它们。 发送方应继续发送段，直到窗口已满或 ByteStream 为空。 
* 跟踪哪些段已发送但接收方尚未确认——我们称这些“未完成”段 (`outstanding segments`)
* 如果自发送后经过足够长的时间且尚未确认，则重新发送未完成的段

> 我为什么要这样做？ 
> 基本原则是发送接收方允许我们发送的任何内容（填充窗口），并继续重传，直到接收方确认每个段。 **这称为“自动重复请求”（ARQ）。** 发送者将字节流分成多个段并发送它们，只要接收者的窗口允许。 感谢您上周的工作，我们知道远程 TCP 接收器可以重建字节流，只要它至少接收每个带索引标记的字节一次 — 无论顺序如何。 发送者的工作是确保接收者至少获得每个字节一次。



### TCPSender 如何知道段丢失了

您的 TCPSender 将发送一堆 TCPSegments。 每个将包含来自传出 ByteStream 的（可能为空的）子字符串，用序列号索引以指示其在流中的位置，并在流的开头用 SYN 标志标记，在结尾用 FIN 标志标记。

除了发送这些段之外，TCPSender 还必须跟踪其未完成的段，直到它们占据的序列号被完全确认。 TCPSender 的所有者会定期调用 TCPSender 的 tick 方法，指示时间的流逝。 TCPSender 负责查看其未完成的 TCPSegments 的集合，并确定最旧的发送段是否在未确认的情况下已未完成的时间过长（即，未确认其所有序列号）。 如果是，则需要重新发送（再次发送）。

以下是“outstanding for too long”的含义的规则。你将要实现这个逻辑，它有点详细，但我们不希望你担心隐藏的测试用例试图绊倒你 或将其视为 SAT 上的应用题。 本周我们会给你一些合理的单元测试，一旦你完成了整个 TCP 实现，我们将在 Lab 4 中进行更全面的集成测试。 只要你 100% 通过这些测试并且你的实现是合理的，你会没事的。



>我为什么要这样做？ 
>总体目标是让发件人及时发现段丢失并需要重新发送。 重新发送之前等待的时间很重要：您不希望发送方等待太久来重新发送一个段（因为这会延迟流向接收应用程序的字节），但您也不希望它重新发送一个 如果发件人稍等片刻，该段将被确认——这浪费了 Internet 的宝贵容量。



1. 每隔几毫秒，您的 TCPSender 的 tick 方法将被调用，并带有一个参数，该参数告诉它自上次调用该方法以来已经过去了多少毫秒。使用它来维护 TCPSender 已存活的总毫秒数的概念。**请不要尝试从操作系统或 CPU 调用任何“时间”或“时钟”函数**——tick 方法是您唯一可以访问时间流逝的方法。这使事情具有确定性和可测试性。
2. 当 TCPSender 被构造时，它被赋予一个参数，告诉它重传超时 (RTO) 的“初始值”。 **RTO 是在重新发送未完成的 TCP 段之前等待的毫秒数。 RTO 的值会随时间变化，但“初始值”保持不变**。起始代码将 RTO 的“初始值”保存在称为初始重传超时的成员变量中。 
3. 您将实现重传计时器：可以在特定时间启动的警报，并且一旦 RTO 过去，警报就会关闭（或“到期”）。**我们强调这个时间流逝的概念来自被调用的 tick 方法,而不是通过获取一天中的实际时间**
4. 每次发送一个包含数据的段（序列空间中的非零长度）时（无论是第一次还是重传），如果定时器没有运行，则启动它，使其在 RTO 毫秒后到期（对于当前值为 RTO）。 通过“过期”，我们的意思是时间将在未来用完一定的毫秒数。
5. 当所有未完成的数据都被确认后，停止重传计时器
6. 如果调用了 tick 并且重传计时器已到期：

	  * 重传尚未被 TCP 接收方完全确认的最早（最低序列号）段。 您需要将未完成的段存储在一些内部数据结构中，以便可以执行此操作。

	* 如果窗口大小不为零： 
		* 跟踪**连续**重传的次数，并增加它，因为你刚刚重传了一些东西。 您的 TCPConnection 将使用此信息来确定连接是否无望（连续重传太多）并需要中止。
		* RTO 的数值翻倍。 这被称为“指数退避”——它会减慢糟糕网络上的重传速度，以避免进一步混淆工作。 

	* 重置重传计时器并启动它，使其在 RTO 毫秒后到期（考虑到您可能刚刚将 RTO 的值翻了一番！）。

7. 当接收方给发送方一个确认成功接收新数据的`ackno`（`ackno`反映的`absolute sequence number`大于任何先前的`ackno`）：

	  * 将 RTO 设置回其“初始值”。

	  * 如果发送方有任何未完成的数据，重新启动重传计时器，使其在 RTO 毫秒后到期（对于 RTO 的当前值）。 

	  * 将“连续重传”计数重置为零。


我们建议在单独的类中实现重传计时器的功能，但这取决于您。 如果这样做，请将其添加到现有文件（`tcp_sender.hh` 和 `tcp_sender.cc`）中。



### 实现 TCP sender

好的！ 我们已经讨论了 TCP 发送方做什么的基本概念（给定一个传出的 ByteStream，将其分成多个段，将它们发送给接收方，如果它们没有尽快得到确认，则继续重新发送它们）。 我们已经讨论过什么时候可以得出结论，一个未完成的片段丢失了，需要重新发送。 

现在是时候使用 TCPSender 将提供的具体接口了。 它需要处理四个重要事件，每个事件最终都可能发送一个 TCPSegment：

1. `void fill_window()`
	TCPSender 被要求填充窗口：它从其输入 ByteStream 中读取，并以 TCPSegments 的形式发送尽可能多的字节，只要有新的字节要读取并且窗口中有可用空间。

	您需要确保您发送的每个 TCPSegment 都完全适合接收器的窗口。 使每个单独的 TCPSegment 尽可能大，但不大于 `TCPConfig::MAX_PAYLOADSIZE`（1452 字节）给出的值。 

	可以使用 `TCPSegment::length_in_sequence_space()` 方法统计一个段占用的序号总数。 请记住，SYN 和 FIN 标志也各自占用一个序列号，这意味着它们占用了窗口中的空间。

	> 如果窗口大小为零怎么办？ 
	> 如果接收方宣布窗口大小为零，则填充窗口方法应该像窗口大小为一一样。 发送方最终可能会发送一个被接收方拒绝（且未确认）的字节，但这也可能促使接收方发送一个新的确认段，在该段中它显示在其窗口中打开了更多空间。 没有这个，发件人永远不会知道它被允许再次开始发送。

2. `void ack_received( const WrappingInt32 ackno, const uint16 t window size)`
	从接收器接收到一个段，传送窗口的新左（= ackno）和右（= ackno + window size）边缘。 TCPSender 应该查看它的未完成段的集合并删除任何现在已经完全确认的（确认大于段中的所有序列号）。 **如果打开了新空间，TCPSender 应该再次填充窗口。**

3. `void tick( const size t ms since last tick )`
	时间已经过去：自上次调用此方法以来经过了一定的毫秒数。 发送方可能需要重新传输未完成的段。

4. `void send_empty_segment()`
	TCPSender 应该生成并发送一个 TCPSegment，该 TCPSegment 在序列空间中长度为零，并且序列号设置正确。 如果所有者（您将在下周实现的 TCPConnection）想要发送一个空的 ACK 段，这将非常有用。 
	注意：像这样的段，不占用序列号，不需要被跟踪为“未完成”，并且永远不会被重新传输。

要完成实验 3，请查看文档中的完整界面，网址为 https://cs144.github.io/doc/lab3/class_t_c_p_sender.html 并在 `tcp_sender.hh` 和 `tcp_sender.cc` 文件中实现完整的 TCPSender 公共接口。 我们希望您想要添加私有方法和成员变量，可能还有一个辅助类。



### 测试理论

为了测试你的代码，测试套件会期望它经历一系列的情况——从发送第一个 SYN 段，到发送所有数据，到发送 FIN 段，最后确认 FIN 段。 我们认为您不希望创建更多的状态变量来跟踪这些“状态”——这些状态只是由 TCPSender 类的已经公开的公共接口定义的。 但是为了帮助您理解测试输出，这里是 TCPSender 在流的整个生命周期中的预期演变图。 （在实验 4 之前，您不必担心错误状态或 RST 标志。）

![image.png](https://s2.loli.net/2022/09/09/D5sSgnOjuYltTKZ.png)

### FAQs 和特殊情况

**1 我如何“发送”一个片段？** 

将其推送到分段输出队列。 就您的 TCPSender 而言，请考虑将其推送到此队列后立即发送。 很快，所有者就会出现并弹出它（使用公共的 `segements_out()` 访问器方法）并真正发送它。



**2 等等，我如何既“发送”一个段，又如何跟踪同一段未完成，这样我就知道以后要重新传输什么？ 那我不是必须复制每个片段吗？ 这很浪费吗？**

当您发送包含数据的段时，您可能希望将其推送到段输出队列中，并在数据结构内部保留一份副本，以便您跟踪未完成的段以进行可能的重新传输。 事实证明这并不是很浪费，因为段的有效负载存储为一个引用计数的只读字符串（一个 Buffer 对象）。 所以不用担心——它实际上并没有复制有效负载数据。



**3 在我从接收方获得 ACK 之前，我的 TCPSender 应该假设接收方的窗口大小是多少？**

一字节



**4 如果确认仅部分确认了某些未完成的段，我该怎么办？ 我应该尝试剪掉得到确认的字节吗？**

TCP 发送方可以做到这一点，但就`class`（课程 or 类？）而言，无需花哨。 将每个段视为完全未完成，直到它被完全确认 - 它占用的所有序列号都小于`ackno`。



**5 如果我发送三个包含“a”、“b”和“c”的单独段，但它们从未得到确认，我以后可以在一个包含“abc”的大段中重新传输它们吗？ 还是我必须单独重新传输每个片段？**

再说一遍：TCP 发送者可以做到这一点，但是对于这个`class`（课程 or 类？）的目的，不需要花哨。 只需单独跟踪每个未完成的段，当重传计时器到期时，再次发送最早的未完成段。



 **6 我应该在我的 “outstanding” 数据结构中存储空段并在必要时重新传输它们吗？**

不，唯一应该被跟踪为未完成并可能重新传输的段是那些传送一些数据的段。即， 在序列空间中消耗一些长度。 不占用序列号（无负载、SYN 或 FIN）的段不需要被记住或重新传输。



## 代码

![Lab3](../../../../CS144/Lab3.png)



## 测试

