# Lab4 实现 TCP Connection

## 概述

在 Lab 0 中，您实现了流控制字节流 (ByteStream) 的抽象。 在实验 1、2 和 3 中，您实现了在该抽象和 Internet 提供的抽象之间双向转换的工具：不可靠的数据报。

 现在，在实验 4 中，您将创建名为 TCPConnection 的总体模块，它结合了 TCPSender 和 TCPReceiver 并处理连接的全局管理。 连接的 TCP 段可以封装到用户（TCP-in-UDP）或 Internet (TCP/IP) datagrams，让您的代码与 Internet 上使用相同 TCP/IP  的数十亿台计算机通信。图片 1 再次展示了总体设计。



![image-20220726103422931](https://s2.loli.net/2022/07/26/e5I4HkRsF7calqN.png)

一个简短的注意事项：TCPConnection 大多只是结合了您在早期实验中实现的发送器和接收器模块——TCPConnection 本身可以用不到 100 行代码来实现。 如果您的发送者和接收者很健壮，这将是一个简短的实验。 如果没有，您可能需要在测试失败消息的帮助下花时间进行调试。 （我们不鼓励你尝试阅读测试源代码，除非是万不得已。）基于去年学生的双峰体验，我们强烈建议你早点开始，直到前一天晚上才离开这个实验室 最后期限。



## 设计

## TCP connection

本周，您将完成构建一个有效的 TCP 实现。 你已经完成了大部分工作：你已经实现了发送者和接收者。 你本周的工作是将它们“连接”在一起成为一个对象（一个 TCPConnection），并处理一些全局性的连接任务。 

回想一下：TCP 可靠地传送一对流控制的字节流，每个方向一个。 两方参与 TCP 连接，每一方同时充当（其自己的出站字节流的）“发送者”和（入站字节流的）“接收者”：

![image.png](https://s2.loli.net/2022/09/13/qy9sbAz8BWP3F7h.png)

两方（上图中的“A”和“B”）被称为连接的“端点”或“对等点”。 您的 `TCPConnection` 充当对等方之一。 它负责接收和发送段，确保发送方和接收方被告知并有机会为他们关心的传入和传出段的字段做出贡献。 以下是 `TCPConnection` 必须遵循的基本规则：

**接收段**

如图 1 所示，当调用它的段接收方法时，`TCPConnection` 从 `Internet` 接收 `TCPSegments`。 发生这种情况时，`TCPConnection` 会查看该段并：

* 如果设置了 `RST`（重置）标志，则将入站和出站流都设置为错误状态并永久终止连接。否则它。
* 将段提供给 `TCPReceiver`，以便它可以检查传入段上它关心的字段：`seqno`、`SYN`、`payload` 和 `FIN`。 
* 如果设置了 `ACK` 标志，则告诉 `TCPSender` 它关心传入段的字段：`ackno` 和 `window_size`。 
* 如果输入段占用任何序列号，`TCPConnection` 确保至少发送一个段作为回复，以反映确认和窗口大小的更新。 
* 在 `TCPConnection` 的 `segment_received()` 方法中，您必须处理一种额外的特殊情况：响应“keep-alive”段。对等方可能会选择发送带有无效序列号的段，以查看您的 TCP 实现是否仍然有效（如果是，您当前的窗口是什么）。你的 `TCPConnection` 应该回复这些“keep-alives”，即使它们不占用任何序列号。实现它的代码如下所示：

```c++
if (_receiver.ackno().has_value() and (seg.length_in_sequence_space() == 0)
    and seg.header().seqno == _receiver.ackno().value() - 1) {
    _sender.send_empty_segment();
}
```

**发送段** 

`TCPConnection` 将通过 `Internet` 发送 `TCPSegments`： 

* **任何时候** `TCPSender` 将一个段推送到其传出队列，并在传出段上设置它负责的字段：（`seqno`、`SYN` 、`payload` 和 `FIN`）。 
* 在发送段之前，`TCPConnection` 将向 `TCPReceiver` 询问它在传出段上负责的字段：`ackno` 和 `window size`。 如果有 `ackno`，它将设置 `ACK` 标志和 `TCPSegment` 中的字段。

**当时间流逝**

 `TCPConnection` 有一个 `tick` 方法，操作系统会定期调用该方法。 发生这种情况时，`TCPConnection` 需要：

* 告诉 `TCPSender` 时间的流逝。
* 如果连续重传次数超过上限 `TCPConfig::MAX RETX ATTEMPTS`，则中止连接，并向对等方发送重置段（设置了 `rst` 标志的空段）。 
* 必要时干净地结束连接（请参阅第 5 节）。

因此，每个 TCPSegment 的整体结构如下所示，“sender-written”和“receiver-written”字段以不同颜色显示：

![image.png](https://s2.loli.net/2022/09/13/rKlvVTmbhYJuZq4.png)



TCPConnection 的完整接口在类文档中。 请花一些时间阅读此内容。 您的大部分实现将涉及将 TCPConnection 的公共 API“连接”到 TCPSender 和 TCPReceiver 中的适当例程。 尽可能地，您希望将任何繁重的工作推迟到您已经实现的发送方和接收方。 也就是说，并非所有事情都那么简单，并且有一些微妙之处涉及整体连接的“全局”行为。 最困难的部分将是决定何时完全终止 TCPConnection 并声明它不再“活动”。 以下是您需要处理的一些常见问题解答和边缘案例的详细信息。



### FAQs 和 特殊情况

**您期望有多少代码？** 

总的来说，我们预计实现（在 `tcp connection.cc` 中）总共需要大约 100-150 行代码。 完成后，测试套件将广泛测试您与您自己的实现以及 Linux 内核的 TCP 实现的互操作性。



**我应该如何开始？**

可能最好的开始方法是将一些“ordinary”方法连接到 `TCPSender` 和 `TCPReceiver` 中的适当调用。 这可能包括诸如`remaining_outbound_capacity()`、`bytes_in_flight()` 和 `unassembled_bytes()` 之类的东西。 然后您可以选择实现“writer”方法：`connect()`、`write() `和 `end_input_stream()`。 其中一些方法可能需要对出站 `ByteStream`（由 `TCPSender` 拥有）做一些事情并告诉 TCPSender。 您可以选择在完全实现每个方法之前开始运行测试套件（ `make check` ）； 测试失败消息可以为您提供有关下一步要解决的问题的线索或指南。



**应用程序如何从`inbound stream`中读取？**

`TCPConnection::inbound_stream()` 已经在头文件中实现。 您无需再做任何事情来支持应用程序读取。



**TCPConnection 是否需要任何花哨的数据结构或算法？**

不，真的没有。 繁重的工作全部由您已经实现的 TCPSender 和 TCPReceiver 完成。 这里的工作实际上只是将所有东西都连接起来，并处理一些挥之不去的连接范围内的微妙之处，这些细节不容易被发送者和接收者考虑在内。



**TCPConnection 是如何实际发送一个段的？**

与 TCPSender 类似——将其推送到分段输出队列。 就您的 TCPConnection 而言，请考虑将其推送到此队列后立即发送。 很快，所有者就会出现并弹出它（使用公共段 out() 访问器方法）并真正发送它。



**TCPConnection 如何了解时间的流逝？**

与 TCPSender 类似——tick() 方法将被定期调用。 请不要使用任何其他方式来告诉时间 - 滴答法是您唯一可以了解时间流逝的方法。 这使事情具有确定性和可测试性。



**如果传入的段设置了一个`RST`标志，TCPConnection 会做什么？**

此标志（“reset”）意味着连接立即死亡。 如果您收到带有 `RST` 的段，您应该在入站和出站 `ByteStreams` 上设置错误标志，并且任何随后对 `TCPConnection::active()` 的调用都应该返回 false。



**我应该什么时候发送一个设置了一个`RST`标志的段？**

有两种情况你会想要中止整个连接： 

1. 如果发送者发送了太多连续的重传但没有成功（超过 `TCPConfig::MAX RETX ATTEMPTS`，即 8）。
2. 如果在连接仍处于活动状态时调用了 `TCPConnection` 析构函数（`active()` 返回 `true`）

发送一个带有 `RST` set 的段与接收一个段有类似的效果：连接已死并且不再 `active()`，并且两个 `ByteStreams` 都应该设置为错误状态。



**等等，但我甚至如何制作一个可以设置rst标志的段？序列号是什么？**

任何流出的段都需要有适当的序列号。你可以强制 你可以通过调用 `TCPSender` 的 `send_empty segment()` 方法，强迫它生成一个具有适当序列号的空段。它的 `send empty segment()` 方法来强制生成一个具有适当序列号的空段。或者你可以让它填满窗口（如果它有未完成的信息要发送，例如，生成 如果它有未完成的信息要发送，例如，来自流的字节或 `SYN/FIN`），调用它的 `fill_window()` 方法。



**`ACK`标志的作用是什么？不是一直有一个ackno吗？**

**几乎每个**TCPSegment都有一个ackno，并设置了ack标志。例外的情况是在连接的最开始，在接收方有任何需要确认的东西之前。
**在传出段中**，你要尽可能地设置ackno和ack标志。也就是说，只要TCPReceiver的ackno()方法返回一个 `std::optional<WrappingInt32>`，它有一个值，你可以用has value()测试。
**在传入的段中**，只有在ack字段被设置的情况下，你才会想看看ackno。设置。如果是这样，就把这个ackno（和窗口大小）给TCPSender。



**我如何解读这些 "状态 "名称（如 "流开始 "或 "流进行中"）？**

请看实验二和实验三讲义中的图表。
我们想再次强调，这些 "状态 "对测试和调试很有用，但是 我们并不要求你在代码中实现这些状态。你不需要 制作更多的状态变量来跟踪这些状态。状态 "只是一个 公共接口的功能。



**如果 TCP 接收器想要通告一个大于 `TCP Segment::header().win` 字段的窗口大小，我应该发送什么窗口大小？**

尽可能发送最大的价值。 您可能会发现 `std::numeric_limits` 类很有帮助。



**TCP 连接何时“完成”？ active() 什么时候可以返回 false？**

请看下一节



### TCP connection 的终端：共识需要的工作

TCP connection 的一项重要功能是决定 TCP 连接何时完全“完成”。 发生这种情况时，实现将其独占声明释放给本地端口号，停止发送确认以回复传入的段，将连接视为历史，并使其 active() 方法返回 false。有两种方式可以结束连接。在非正常关闭中，TCPConnection 发送或接收设置了 `RST` 标志的段。在这种情况下，出站和入站 ByteStream 都应该处于错误状态，并且 active() 可以立即返回 false。

干净关闭是我们如何“完成”（active() = false）而不会出现错误。这更复杂，但它是一件美好的事情，因为它尽可能确保两个 ByteStream 中的每一个都已完全可靠地传递给接收对等方。在下一节（第 5.1 节）中，我们给出了干净关闭发生时的实际结果，因此，如果您愿意，请随意跳过。

酷，你还在这里。由于两个将军问题，不可能保证两个对等点都能完全关闭，但 TCP 非常接近。就是这样。从一个对等点（一个 TCPConnection，我们将其称为“本地”对等点）的角度来看，在与“远程”对等点的连接中完全关闭有四个先决条件：

* Prereq #1 入站流已完全组装并已结束。 
* Prereq #2 出站流已由本地应用程序结束并完全发送（包括它结束的事实，即带有 `FIN` 的段）到远程对等点。 
* Prereq #3 出站流已被远程对等方完全确认。 
* Prereq #4 本地 TCPConnection 确信远程对等方可以满足先决条件 #3。 这是大脑弯曲的部分。 有两种替代方法可以发生这种情况：
	* 选项A：在两个流结束后徘徊。先决条件 #1 到 #3 为真，并且远程对等点似乎已获得本地对等点对整个流的确认。本地对等点并不确定这一点——TCP 不能可靠地传递确认（它不确认确认）。但是本地对等点非常确信远程对等点已经得到了它的确认，因为远程对等点似乎没有重新传输任何东西，而本地对等点已经等待了一段时间来确定。具体而言，当满足先决条件 #1 到 #3 并且自从本地对等方已收到来自远程对等方的任何段以来，连接已至少是初始重传超时（cfg.rt 超时）的 10 倍。这在两个流完成后称为“延迟”，以确保远程对等方不会尝试重新传输我们需要确认的任何内容。这确实意味着 TCPConnection 需要保持活动一段时间，1 保持对本地端口号的独占声明，并可能发送 ack 作为响应到传入的段，即使在 TCP 发送者和接收者完全完成他们的工作并且两个流都结束之后。
	* 选项 B：被动关闭。先决条件 #1 到 #3 为真，并且本地对等点 100% 确定远程对等点可以满足先决条件 #3。 如果 TCP 不确认确认，这怎么可能？ 因为远程对等方是第一个结束其流的。



> 为什么这条规则有效？这是脑筋急转弯，您无需进一步阅读即可完成本实验，但思考并了解两位将军问题的深层原因以及不可靠网络对可靠性的固有限制是很有趣的。这样做的原因是，在接收并组装远程对等方的 `FIN` （先决条件＃1）之后，本地对等方发送了一个比它以前发送的序列号更大的段（至少，它必须发送自己的 `FIN` 段以满足先决条件#2)，并且该段也有一个确认远程对等端的 `FIN` 位的 ackno。远程对等点确认了该段（以满足先决条件＃3），这意味着远程对等点也必须看到本地对等点对远程对等点 `FIN` 的确认。这保证了远程对等点必须能够满足其自身的先决条件#3。所有这一切意味着本地对等点可以满足先决条件 #4 而不必逗留。哇！我们说这是一个脑筋急转弯。在你的实验室文章中加分：你能找到更好的方法来解释这一点吗？



底线是，如果 TCP Connections 入站流在 TCP Connection 发送 `FIN` 段之前结束，则 TCP Connection 不需要在两个流完成后逗留。



### TCP connection (实践总结)

实际上，这一切意味着您的 TCPConnection 在流完成后有一个名为 `_linger_after_streams_finish` 的成员变量，通过`state()` 方法暴露给测试设备。 变量开始为真。 如果入站流在 `TCPConnection` 在其出站流上达到 `EOF` 之前结束，则需要将此变量设置为 false。 在满足先决条件 #1 到 #3 的任何时候，如果流完成后的 linger 为假，则连接“完成”（并且 active() 应该返回假）。 否则你需要拖延：连接只有在收到最后一个段后经过足够的时间（`10 × _cfg.rt` 超时）后才完成。



## 代码





## 测试

