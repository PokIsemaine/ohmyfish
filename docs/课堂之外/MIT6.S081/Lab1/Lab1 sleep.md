# Lab: Xv6 and Unix utilities

## sleep ([easy](https://pdos.csail.mit.edu/6.S081/2021/labs/guidance.html))

Implement the UNIX program `sleep` for xv6; your `sleep` should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file `user/sleep.c`.



Some hints:

- Before you start coding, read Chapter 1 of the [xv6 book](https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf).
- Look at some of the other programs in `user/` (e.g., `user/echo.c`, `user/grep.c`, and `user/rm.c`) to see how you can obtain the command-line arguments passed to a program.
- If the user forgets to pass an argument, sleep should print an error message.
- The command-line argument is passed as a string; you can convert it to an integer using `atoi` (see user/ulib.c).
- Use the system call `sleep`.
- See `kernel/sysproc.c` for the xv6 kernel code that implements the `sleep` system call (look for `sys_sleep`), `user/user.h` for the C definition of `sleep` callable from a user program, and `user/usys.S` for the assembler code that jumps from user code into the kernel for `sleep`.
- Make sure `main` calls `exit()` in order to exit your program.
- Add your `sleep` program to `UPROGS` in Makefile; once you've done that, `make qemu` will compile your program and you'll be able to run it from the xv6 shell.
- Look at Kernighan and Ritchie's book *The C programming language (second edition)* (K&R) to learn about C.

Run the program from the xv6 shell:

```shell
$ make qemu
...
init: starting sh
$ sleep 10
(nothing happens for a little while)
$
```

Your solution is correct if your program pauses when run as shown above. Run make grade to see if you indeed pass the sleep tests.

Note that make grade runs all tests, including the ones for the assignments below. If you want to run the grade tests for one assignment, type:

```shell
$ ./grade-lab-util sleep
```

This will run the grade tests that match "sleep". Or, you can type:

```shell
$ make GRADEFLAGS=sleep grade
```

which does the same.

## 思路

直接系统调用就可以了

### C语言传命令行参数

```c
int 
main(int argc, char *argv[]) {//argc 表示参数数量，argv 为传入参数的数组(字符串形式)
}

//sleep 10
//argc = 2
//argv[0] = "sleep",第0个参数为调用者本身
//argv[1] = "2"
```

### atoi

`user/ulib.c`文件中

```c
int
atoi(const char *s)//传入char* 转为 int
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
    n = n*10 + *s++ - '0';
  return n;
}
```

### sleep 系统调用

xv6的`sleep`系统调用是如何实现的呢？（下面代码只筛选了`sleep`相关的部分）

参考https://www.cnblogs.com/weijunji/p/14338408.html

如何不参考这些资料自己寻找调用链？

* 自己造一个工具
* gdb

1. 在`user/user.h`中添加系统调用

```c
//system call
int sleep(int);
```

2. 在`user/usys.pl`中添加入口`make qmue`后会生成`user/usys.S`

```perl
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}

# 添加 sleep 入口
entry("sleep"); 
```

3. `usys.S`中节选的`SYS_sleep`调用

```assembly
.global sleep
sleep:
 li a7, SYS_sleep	# 将系统调用号通过 li(load imm)存入a7
 ecall	# 使用ecall进入内核态    能不能不进入内核态调用SYS_sleep?
 ret	# 返回
```

4. 在`kernel/syscall.h`中定义系统调用号

```c
// System call numbers
#define SYS_sleep  13
```

5. 在`kernel/syscall.c`的`syscalls`函数指针数组中添加对应的函数。

```c
static uint64 (*syscalls[])(void) = {
[SYS_sleep]   sys_sleep, //在数组中下标为13,对应SYS_sleep 13
};
```

5. 在`kernel/syscall.c`的`syscall`函数中，先读取`trapframe->a7`获取系统调用号

```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();//左半部分什么意思？
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

6. 之后根据该系统调用号在`kernel/sysproc.c`查找`syscalls`数组中的对应的处理函数并调用。

```c
uint64
sys_sleep(void)
{
  int n;
  uint ticks0;

  if(argint(0, &n) < 0)//argint？是这个传
    return -1;
  acquire(&tickslock);
  ticks0 = ticks;
  while(ticks - ticks0 < n){
    if(myproc()->killed){
      release(&tickslock);
      return -1;
    }
    sleep(&ticks, &tickslock);
  }
  release(&tickslock);
  return 0;
}
```

7. 调用`/kernel/proc.c`里的`sleep(&ticks,&tickslock)`

```c
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
void
sleep(void *chan, struct spinlock *lk)
{
  struct proc *p = myproc();
  
  // Must acquire p->lock in order to
  // change p->state and then call sched.
  // Once we hold p->lock, we can be
  // guaranteed that we won't miss any wakeup
  // (wakeup locks p->lock),
  // so it's okay to release lk.

  acquire(&p->lock);  //DOC: sleeplock1
  release(lk);

  // Go to sleep.
  p->chan = chan;
  p->state = SLEEPING;

  sched();

  // Tidy up.
  p->chan = 0;

  // Reacquire original lock.
  release(&p->lock);
  acquire(lk);
}
```



## 代码

```c
#include "../kernel/types.h"	
#include "../user/user.h" 		

int 
main(int argc, char *argv[]) {
	int n;

	//If the user forgets to pass an argument, sleep should print an error message. 
	if (argc < 2) {
		fprintf(2, "Usage: sleep ticks\n");
    	exit(1);
	}

	if((n = sleep(atoi(argv[0]))) < 0) {
		fprintf(2, "sleep returned with error %d", n);
		exit(1);
	}
	exit(0);
}
```

