<h1>Lab: Xv6 and Unix utilities</h1>
<h2>sleep <script>g("easy")</script></h2>

<div class="required">
<p>Implement the UNIX program <tt>sleep</tt> for xv6; your <tt>sleep</tt> should pause
  for a user-specified number of ticks.  A tick is a notion of time
  defined by the xv6 kernel, namely the time between two interrupts
  from the timer chip.  Your solution should be in the file
  <tt>user/sleep.c</tt>.
</div>



<p>Some hints:
  <ul>
    <li>Before you start coding, read Chapter 1 of
    the <a href="../xv6/book-riscv-rev2.pdf">xv6 book</a>.
    <li>Look at some of the other programs in <tt>user/</tt>
    (e.g., <tt>user/echo.c</tt>, <tt>user/grep.c</tt>,
    and <tt>user/rm.c</tt>)
    to see
    how you can obtain the command-line arguments passed to a program.
    <li>If the user
    forgets to pass an argument, sleep should print an error message.
    <li>The command-line argument is passed as a string; you can convert it to an
      integer using <tt>atoi</tt> (see user/ulib.c).
    <li>Use the system call <tt>sleep</tt>.
    <li>See <tt>kernel/sysproc.c</tt> for
    the xv6 kernel code that implements the <tt>sleep</tt> system
    call (look for <tt>sys_sleep</tt>), <tt>user/user.h</tt>
    for the C definition of <tt>sleep</tt> callable from a
    user program, and <tt>user/usys.S</tt> for the assembler
    code that jumps from user code into the kernel for <tt>sleep</tt>.
    <li>Make sure <tt>main</tt> calls <tt>exit()</tt> in order to exit
    your program.
    <li>Add your <tt>sleep</tt> program to <tt>UPROGS</tt> in Makefile; once you've
    done that, <tt>make qemu</tt> will compile your program and you'll
    be able to run it from the xv6 shell.
  </ul>



  <p>Run the program from the xv6 shell:
    <pre>
      $ <kbd>make qemu</kbd>
      ...
      init: starting sh
      $ <kbd>sleep 10</kbd>
      (nothing happens for a little while)
      $
    </pre>
  <p>Your solution is correct if your program pauses when
  run as shown above.
  Run <kbd>make grade</kbd> to see if you indeed pass the
    sleep tests.

 <p>Note that <kbd>make grade</kbd> runs all tests, including the ones for the assignments
 below. If you want to run the grade tests for one assignment, type:
   <pre>
     $ <kbd>./grade-lab-util sleep</kbd>
   </pre>
   This will run the grade tests that match "sleep".  Or, you can type:
   <pre>
     $ <kbd>make GRADEFLAGS=sleep grade</kbd>
   </pre>
   which does the same.


## 思路

直接系统调用就可以了

### C语言传命令行参数

```c
int 
main(int argc, char *argv[]) {//argc 表示参数数量，argv 为传入参数的数组(字符串形式)
}

//sleep 10
//argc = 2
//argv[0] = "sleep",第0个参数为调用者本身
//argv[1] = "2"
```

### atoi

`user/ulib.c`文件中

```c
int
atoi(const char *s)//传入char* 转为 int
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
    n = n*10 + *s++ - '0';
  return n;
}
```

### sleep 系统调用

xv6的`sleep`系统调用是如何实现的呢？（下面代码只筛选了`sleep`相关的部分）

参考https://www.cnblogs.com/weijunji/p/14338408.html

如何不参考这些资料自己寻找调用链？

* 自己造一个工具
* gdb

1. 在`user/user.h`中添加系统调用

```c
//system call
int sleep(int);
```

2. 在`user/usys.pl`中添加入口`make qmue`后会生成`user/usys.S`

```perl
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}

# 添加 sleep 入口
entry("sleep"); 
```

3. `usys.S`中节选的`SYS_sleep`调用

```assembly
.global sleep
sleep:
 li a7, SYS_sleep	# 将系统调用号通过 li(load imm)存入a7
 ecall	# 使用ecall进入内核态    能不能不进入内核态调用SYS_sleep?
 ret	# 返回
```

4. 在`kernel/syscall.h`中定义系统调用号

```c
// System call numbers
#define SYS_sleep  13
```

5. 在`kernel/syscall.c`的`syscalls`函数指针数组中添加对应的函数。

```c
static uint64 (*syscalls[])(void) = {
[SYS_sleep]   sys_sleep, //在数组中下标为13,对应SYS_sleep 13
};
```

5. 在`kernel/syscall.c`的`syscall`函数中，先读取`trapframe->a7`获取系统调用号

```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();//左半部分什么意思？
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

6. 之后根据该系统调用号在`kernel/sysproc.c`查找`syscalls`数组中的对应的处理函数并调用。

```c
uint64
sys_sleep(void)
{
  int n;
  uint ticks0;

  if(argint(0, &n) < 0)//argint？是这个传
    return -1;
  acquire(&tickslock);
  ticks0 = ticks;
  while(ticks - ticks0 < n){
    if(myproc()->killed){
      release(&tickslock);
      return -1;
    }
    sleep(&ticks, &tickslock);
  }
  release(&tickslock);
  return 0;
}
```

7. 调用`/kernel/proc.c`里的`sleep(&ticks,&tickslock)`

```c
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
void
sleep(void *chan, struct spinlock *lk)
{
  struct proc *p = myproc();
  
  // Must acquire p->lock in order to
  // change p->state and then call sched.
  // Once we hold p->lock, we can be
  // guaranteed that we won't miss any wakeup
  // (wakeup locks p->lock),
  // so it's okay to release lk.

  acquire(&p->lock);  //DOC: sleeplock1
  release(lk);

  // Go to sleep.
  p->chan = chan;
  p->state = SLEEPING;

  sched();

  // Tidy up.
  p->chan = 0;

  // Reacquire original lock.
  release(&p->lock);
  acquire(lk);
}
```



## 代码

```c
#include "../kernel/types.h"	
#include "../user/user.h" 		

int 
main(int argc, char *argv[]) {
	int n;

	//If the user forgets to pass an argument, sleep should print an error message. 
	if (argc < 2) {
		fprintf(2, "Usage: sleep ticks\n");
    	exit(1);
	}

	if((n = sleep(atoi(argv[0]))) < 0) {
		fprintf(2, "sleep returned with error %d", n);
		exit(1);
	}
	exit(0);
}
```

